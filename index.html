<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PE 전용 딥 리서치</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Pretendard', 'Noto Sans KR', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #f5f6f8;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding: 40px 20px;
        }
        
        .container {
            background: #ffffff;
            border-radius: 12px;
            padding: 48px;
            width: 100%;
            max-width: 1200px;
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.08);
            border: 1px solid #e8e8e8;
        }
        
        h1 {
            text-align: center;
            color: #1a1a1a;
            margin-bottom: 8px;
            font-size: 1.75rem;
            font-weight: 700;
            letter-spacing: -0.5px;
        }
        
        .subtitle {
            text-align: center;
            color: #6b7280;
            margin-bottom: 36px;
            font-size: 0.9rem;
            font-weight: 400;
        }
        
        /* 검색 섹션 */
        .search-section {
            margin-bottom: 20px;
            max-width: 500px;
            margin-left: auto;
            margin-right: auto;
        }
        
        .input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        input[type="text"] {
            flex: 1;
            padding: 12px 16px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            font-size: 0.95rem;
            transition: border-color 0.2s, box-shadow 0.2s;
            background: #fafafa;
        }
        
        input[type="text"]:focus {
            outline: none;
            border-color: #2563eb;
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
            background: #ffffff;
        }
        
        .btn {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 0.95rem;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 500;
        }
        
        .btn-primary {
            background: #2563eb;
            color: white;
        }
        
        .btn-primary:hover {
            background: #1d4ed8;
            box-shadow: 0 2px 8px rgba(37, 99, 235, 0.25);
        }
        
        .btn-danger {
            background: #dc2626;
            color: white;
        }
        
        .btn-danger:hover {
            background: #b91c1c;
            box-shadow: 0 2px 8px rgba(220, 38, 38, 0.25);
        }
        
        .btn-success {
            background: #059669;
            color: white;
        }
        
        .btn-success:hover {
            background: #047857;
            box-shadow: 0 2px 8px rgba(5, 150, 105, 0.25);
        }
        
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        
        /* 검색 히스토리 */
        .search-history {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 12px;
        }
        
        .search-history:empty {
            display: none;
        }
        
        .history-item {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            background: #f3f4f6;
            border: 1px solid #e5e7eb;
            border-radius: 16px;
            font-size: 0.85rem;
            color: #374151;
            cursor: pointer;
            transition: all 0.15s;
        }
        
        .history-item:hover {
            background: #e5e7eb;
        }
        
        .history-item .history-name {
            max-width: 120px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .history-item .history-remove {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #9ca3af;
            color: #fff;
            font-size: 10px;
            line-height: 1;
            cursor: pointer;
            transition: background 0.15s;
        }
        
        .history-item .history-remove:hover {
            background: #6b7280;
        }
        
        /* 검색 결과 */
        .search-results {
            max-height: 250px;
            overflow-y: auto;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            display: none;
            background: #ffffff;
        }
        
        .search-results.show {
            display: block;
        }
        
        .result-item {
            padding: 12px 16px;
            border-bottom: 1px solid #f3f4f6;
            cursor: pointer;
            transition: background 0.15s;
        }
        
        .result-item:hover {
            background: #f9fafb;
        }
        
        .result-item:last-child {
            border-bottom: none;
        }
        
        .result-name {
            font-weight: 500;
            color: #1f2937;
            margin-bottom: 4px;
        }
        
        .result-info {
            font-size: 0.8rem;
            color: #9ca3af;
        }
        
        .result-market {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.7rem;
            margin-left: 8px;
            font-weight: 500;
        }
        
        .market-kospi {
            background: #dbeafe;
            color: #1e40af;
        }
        
        .market-kosdaq {
            background: #fef3c7;
            color: #b45309;
        }
        
        .market-etc {
            background: #f3f4f6;
            color: #4b5563;
        }
        
        /* 진행 상태 섹션 */
        .progress-section {
            display: none;
            margin-top: 24px;
            max-width: 500px;
            margin-left: auto;
            margin-right: auto;
        }
        
        .progress-section.show {
            display: block;
        }
        
        .selected-company {
            background: #f0f9ff;
            border: 1px solid #bae6fd;
            padding: 12px 16px;
            border-radius: 8px;
            margin-bottom: 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .selected-company-name {
            font-weight: 500;
            color: #0c4a6e;
        }
        
        .progress-bar-container {
            background: #e5e7eb;
            border-radius: 6px;
            height: 8px;
            overflow: hidden;
            margin-bottom: 12px;
        }
        
        .progress-bar {
            height: 100%;
            background: #2563eb;
            border-radius: 6px;
            transition: width 0.3s ease;
        }
        
        .progress-message {
            text-align: center;
            color: #6b7280;
            margin-bottom: 16px;
            font-size: 0.9rem;
        }
        
        .action-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        
        /* 완료 섹션 */
        .complete-section {
            display: none;
            text-align: center;
            margin-top: 24px;
        }
        
        .complete-section.show {
            display: block;
        }
        
        .complete-icon {
            font-size: 2rem;
            margin-bottom: 12px;
            color: #059669;
        }
        
        .complete-message {
            font-size: 1rem;
            color: #374151;
            margin-bottom: 16px;
            font-weight: 500;
        }
        
        /* 에러 메시지 */
        .error-message {
            background: #fef2f2;
            color: #b91c1c;
            padding: 12px 16px;
            border-radius: 8px;
            border: 1px solid #fecaca;
            margin-top: 12px;
            display: none;
            font-size: 0.9rem;
        }
        
        .error-message.show {
            display: block;
        }
        
        /* 로딩 스피너 */
        .spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid #ffffff;
            border-radius: 50%;
            border-top-color: transparent;
            animation: spin 1s linear infinite;
            margin-right: 8px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* 연도 선택 */
        .year-selection {
            display: flex;
            gap: 10px;
            margin-top: 12px;
            align-items: center;
            justify-content: center;
        }
        
        .year-selection label {
            color: #6b7280;
            font-size: 0.85rem;
        }
        
        .year-selection select {
            padding: 8px 12px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 0.85rem;
            background: #fafafa;
        }
        
        /* 미리보기 섹션 */
        .preview-section {
            margin-top: 32px;
            text-align: left;
            width: 100%;
        }
        
        .preview-tabs {
            display: flex;
            gap: 4px;
            margin-bottom: 0;
            border-bottom: 1px solid #e5e7eb;
            padding-bottom: 0;
        }
        
        .preview-tab {
            padding: 10px 20px;
            border: 1px solid transparent;
            border-bottom: none;
            background: #f3f4f6;
            border-radius: 6px 6px 0 0;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.15s;
            color: #6b7280;
            font-weight: 500;
            margin-right: 2px;
        }
        
        .preview-tab:hover {
            color: #374151;
            background: #e5e7eb;
        }
        
        .preview-tab.active {
            background: #ffffff;
            color: #1f2937;
            border: 1px solid #e5e7eb;
            border-bottom: 1px solid #ffffff;
            font-weight: 600;
        }
        
        .preview-content {
            border: 1px solid #e5e7eb;
            border-radius: 0 8px 8px 8px;
            background: #ffffff;
            overflow-x: auto;
            margin-top: -1px;
        }
        
        .preview-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.8rem;
        }
        
        .preview-table th,
        .preview-table td {
            padding: 10px 14px;
            border-bottom: 1px solid #f3f4f6;
            text-align: right;
            white-space: nowrap;
        }
        
        .preview-table td:first-child,
        .preview-table th:first-child {
            text-align: left;
            font-weight: 500;
            color: #374151;
        }
        
        .preview-table th {
            background: #f9fafb;
            font-weight: 600;
            color: #4b5563;
            position: sticky;
            top: 0;
            border-bottom: 1px solid #e5e7eb;
        }
        
        .preview-table tr:hover {
            background: #f9fafb;
        }
        
        .preview-placeholder {
            padding: 48px;
            text-align: center;
            color: #9ca3af;
        }
        
        .preview-info {
            font-size: 0.75rem;
            color: #9ca3af;
            margin-top: 8px;
            text-align: center;
        }
        
        .preview-unit {
            font-size: 0.8rem;
            color: #6b7280;
            margin-top: 8px;
            margin-bottom: 8px;
            text-align: left;
            font-weight: 500;
        }
        
        /* VCM 전용 포맷 스타일 */
        .vcm-container {
            display: flex;
            flex-direction: row;
            gap: 20px;
            align-items: flex-start;
        }
        
        .vcm-section {
            flex: 1;
            min-width: 0;
            overflow-x: auto;
        }
        
        .vcm-title {
            background: #1f2937;
            color: white;
            padding: 10px 14px;
            font-weight: 600;
            text-align: center;
            margin-bottom: 0;
            font-size: 0.9rem;
            letter-spacing: 0.5px;
        }
        
        .vcm-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.78rem;
        }
        
        .vcm-table th,
        .vcm-table td {
            padding: 6px 10px;
            border-bottom: 1px solid #e5e7eb;
            text-align: right;
            white-space: nowrap;
        }
        
        .vcm-table th {
            background: #f9fafb;
            font-weight: 600;
            color: #4b5563;
            border-bottom: 1px solid #d1d5db;
        }
        
        .vcm-table td:first-child,
        .vcm-table th:first-child {
            text-align: left;
            color: #374151;
        }
        
        .vcm-table .category-row {
            background: #f3f4f6;
            font-weight: 600;
        }
        
        .vcm-table .sub-item {
            padding-left: 20px;
            color: #6b7280;
        }
        
        .vcm-table .total-row {
            font-weight: 600;
            background: #fef3c7;
            color: #92400e;
        }
        
        .vcm-table .highlight-row {
            color: #dc2626;
            font-weight: 600;
            background: #fef2f2;
        }
        
        .vcm-table .percent-row {
            font-style: normal;
            color: #9ca3af;
            font-size: 0.7rem;
        }

        /* 합산된 셀 스타일 (파란색 글자) */
        .vcm-table .calc-cell {
            color: #2563eb;
            cursor: help;
            position: relative;
        }

        .vcm-table .calc-cell:hover {
            color: #1d4ed8;
            font-weight: 600;
            text-decoration: underline;
        }

        /* 툴팁이 있는 셀 */
        .vcm-table td[title]:not([title=""]) {
            cursor: help;
        }

        .vcm-table td[title]:not([title=""]):hover {
            outline: 2px solid #2563eb;
            outline-offset: -2px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>PE 전용 딥 리서치</h1>
        <p class="subtitle">DART 기반 재무제표 추출 시스템 · 코스피, 코스닥, 코넥스, 비상장</p>
        
        <!-- 검색 섹션 -->
        <div class="search-section">
            <div class="input-group">
                <input type="text" id="companyInput" placeholder="기업명을 입력하세요 (예: 삼성전자)" />
                <button class="btn btn-primary" id="searchBtn" onclick="searchCompany()">검색</button>
            </div>
            
            <!-- 검색 히스토리 -->
            <div class="search-history" id="searchHistory"></div>
            
            <div class="search-results" id="searchResults"></div>
            
            <div class="error-message" id="errorMessage"></div>
        </div>
        
        <!-- 진행 상태 섹션 -->
        <div class="progress-section" id="progressSection">
            <div class="selected-company">
                <span class="selected-company-name" id="selectedCompanyName"></span>
                <button class="btn btn-danger" onclick="resetAll()">✕</button>
            </div>
            
            <div class="year-selection">
                <label>시작 연도:</label>
                <select id="startYear"></select>
                <label>~ 종료 연도:</label>
                <select id="endYear"></select>
                <button class="btn btn-primary" id="extractBtn" onclick="startExtraction()">추출 시작</button>
            </div>
        </div>
        
        <!-- 추출 진행 섹션 -->
        <div class="progress-section" id="extractingSection">
            <div class="progress-bar-container">
                <div class="progress-bar" id="progressBar">0%</div>
            </div>
            <p class="progress-message" id="progressMessage">준비 중...</p>
            <div class="action-buttons">
                <button class="btn btn-danger" id="cancelBtn" onclick="cancelExtraction()">취소</button>
            </div>
        </div>
        
        <!-- 완료 섹션 -->
        <div class="complete-section" id="completeSection">
            <div class="complete-icon">✔</div>
            <p class="complete-message">재무제표 추출 완료</p>
            <div class="action-buttons">
                <button class="btn btn-success" id="downloadBtn" onclick="downloadFile()">엑셀 다운로드</button>
                <button class="btn btn-primary" onclick="resetAll()">새로 검색</button>
            </div>
            
            <!-- 미리보기 탭 -->
            <div class="preview-section" id="previewSection">
                <div class="preview-tabs">
                    <button class="preview-tab active" data-tab="vcm" onclick="showPreviewTab('vcm')">VCM 전용 포맷</button>
                    <button class="preview-tab" data-tab="bs" onclick="showPreviewTab('bs')">재무상태표</button>
                    <button class="preview-tab" data-tab="is" onclick="showPreviewTab('is')">손익계산서</button>
                    <button class="preview-tab" data-tab="cf" onclick="showPreviewTab('cf')">현금흐름표</button>
                </div>
                <div class="preview-content" id="previewContent">
                    <p class="preview-placeholder">데이터 로딩 중...</p>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // ============================================================
        // 전역 변수
        // ============================================================
        let selectedCorp = null;  // 선택된 기업 정보
        let currentTaskId = null;  // 현재 작업 ID
        let statusCheckInterval = null;  // 상태 확인 인터벌
        let previewData = null;  // 미리보기 데이터
        
        // ============================================================
        // 초기화
        // ============================================================
        document.addEventListener('DOMContentLoaded', function() {
            // 연도 선택 옵션 생성
            const currentYear = new Date().getFullYear();
            const startYearSelect = document.getElementById('startYear');
            const endYearSelect = document.getElementById('endYear');
            
            // 시작 연도: 5년 전부터 2015년까지
            const defaultStartYear = currentYear - 5;
            for (let year = currentYear; year >= 2015; year--) {
                startYearSelect.add(new Option(year, year));
                endYearSelect.add(new Option(year, year));
            }
            
            // 기본값: 5년 전 ~ 현재
            startYearSelect.value = defaultStartYear;
            endYearSelect.value = currentYear;
            
            // Enter 키로 검색
            document.getElementById('companyInput').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    searchCompany();
                }
            });
            
            // 브라우저 종료 시 작업 취소
            window.addEventListener('beforeunload', function(e) {
                if (currentTaskId) {
                    cancelExtraction();
                }
            });
        });
        
        // ============================================================
        // 검색 히스토리 (로컬 스토리지)
        // ============================================================
        const HISTORY_KEY = 'pe_search_history';
        const MAX_HISTORY = 5;
        
        function getSearchHistory() {
            try {
                return JSON.parse(localStorage.getItem(HISTORY_KEY)) || [];
            } catch {
                return [];
            }
        }
        
        function saveSearchHistory(history) {
            localStorage.setItem(HISTORY_KEY, JSON.stringify(history));
        }
        
        function addToHistory(companyName) {
            let history = getSearchHistory();
            // 중복 제거
            history = history.filter(h => h !== companyName);
            // 맨 앞에 추가
            history.unshift(companyName);
            // 최대 5개 유지
            if (history.length > MAX_HISTORY) {
                history = history.slice(0, MAX_HISTORY);
            }
            saveSearchHistory(history);
            renderSearchHistory();
        }
        
        function removeFromHistory(companyName) {
            let history = getSearchHistory();
            history = history.filter(h => h !== companyName);
            saveSearchHistory(history);
            renderSearchHistory();
        }
        
        function renderSearchHistory() {
            const container = document.getElementById('searchHistory');
            const history = getSearchHistory();
            
            if (history.length === 0) {
                container.innerHTML = '';
                return;
            }
            
            container.innerHTML = history.map(name => `
                <div class="history-item">
                    <span class="history-name" onclick="useHistoryItem('${name}')">${name}</span>
                    <span class="history-remove" onclick="event.stopPropagation(); removeFromHistory('${name}')">✕</span>
                </div>
            `).join('');
        }
        
        function useHistoryItem(companyName) {
            document.getElementById('companyInput').value = companyName;
            searchCompany();
        }
        
        // 페이지 로드 시 히스토리 렌더링
        document.addEventListener('DOMContentLoaded', function() {
            renderSearchHistory();
        });
        
        // ============================================================
        // 기업 검색
        // ============================================================
        async function searchCompany() {
            const companyName = document.getElementById('companyInput').value.trim();
            if (!companyName) {
                showError('기업명을 입력해주세요.');
                return;
            }
            
            // 검색 히스토리에 추가
            addToHistory(companyName);
            
            const searchBtn = document.getElementById('searchBtn');
            searchBtn.disabled = true;
            searchBtn.innerHTML = '<span class="spinner"></span>검색 중...';
            
            hideError();
            
            try {
                const response = await fetch('/api/search', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ company_name: companyName })
                });
                
                const data = await response.json();
                
                if (!response.ok) {
                    throw new Error(data.detail || '검색 실패');
                }
                
                displaySearchResults(data.data);
                
            } catch (error) {
                showError(error.message);
            } finally {
                searchBtn.disabled = false;
                searchBtn.textContent = '검색';
            }
        }
        
        function displaySearchResults(results) {
            const container = document.getElementById('searchResults');
            
            if (results.length === 0) {
                container.innerHTML = '<div class="result-item">검색 결과가 없습니다.</div>';
                container.classList.add('show');
                return;
            }
            
            container.innerHTML = results.map(corp => {
                const marketClass = corp.market === '코스피' ? 'market-kospi' : 
                                   corp.market === '코스닥' ? 'market-kosdaq' : 'market-etc';
                return `
                    <div class="result-item" onclick="selectCompany('${corp.corp_code}', '${corp.corp_name}', '${corp.stock_code}', '${corp.market}')">
                        <div class="result-name">
                            ${corp.corp_name}
                            <span class="result-market ${marketClass}">${corp.market}</span>
                        </div>
                        <div class="result-info">
                            고유번호: ${corp.corp_code}
                            ${corp.stock_code ? ' | 종목코드: ' + corp.stock_code : ''}
                        </div>
                    </div>
                `;
            }).join('');
            
            container.classList.add('show');
        }
        
        // ============================================================
        // 기업 선택
        // ============================================================
        function selectCompany(corpCode, corpName, stockCode, market) {
            selectedCorp = { corpCode, corpName, stockCode, market };
            
            // UI 업데이트
            document.getElementById('searchResults').classList.remove('show');
            document.getElementById('selectedCompanyName').textContent = `${corpName} (${market})`;
            document.getElementById('progressSection').classList.add('show');
        }
        
        // ============================================================
        // 재무제표 추출 시작
        // ============================================================
        async function startExtraction() {
            if (!selectedCorp) return;
            
            const startYear = parseInt(document.getElementById('startYear').value);
            const endYear = parseInt(document.getElementById('endYear').value);
            
            if (startYear > endYear) {
                showError('시작 연도가 종료 연도보다 클 수 없습니다.');
                return;
            }
            
            // UI 전환
            document.getElementById('progressSection').classList.remove('show');
            document.getElementById('extractingSection').classList.add('show');
            
            try {
                const response = await fetch('/api/extract', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        corp_code: selectedCorp.corpCode,
                        corp_name: selectedCorp.corpName,
                        start_year: startYear,
                        end_year: endYear
                    })
                });
                
                const data = await response.json();
                
                if (!response.ok) {
                    throw new Error(data.detail || '추출 시작 실패');
                }
                
                currentTaskId = data.task_id;
                
                // 상태 확인 시작
                startStatusCheck();
                
            } catch (error) {
                showError(error.message);
                resetAll();
            }
        }
        
        // ============================================================
        // 상태 확인
        // ============================================================
        function startStatusCheck() {
            statusCheckInterval = setInterval(checkStatus, 500);
        }
        
        async function checkStatus() {
            if (!currentTaskId) {
                stopStatusCheck();
                return;
            }
            
            try {
                const response = await fetch(`/api/status/${currentTaskId}`);
                const data = await response.json();
                
                if (!response.ok) {
                    throw new Error(data.detail || '상태 확인 실패');
                }
                
                updateProgress(data.progress, data.message);
                
                if (data.status === 'completed') {
                    stopStatusCheck();
                    // 미리보기 데이터 저장
                    previewData = data.preview_data || null;
                    showComplete();
                } else if (data.status === 'error') {
                    stopStatusCheck();
                    // 에러 시 화면 유지하고 에러 메시지만 표시
                    document.getElementById('extractingSection').classList.remove('show');
                    document.getElementById('progressSection').classList.add('show');
                    showError(data.message);
                } else if (data.status === 'cancelled') {
                    stopStatusCheck();
                    resetAll();
                }
                
            } catch (error) {
                console.error('Status check error:', error);
            }
        }
        
        function stopStatusCheck() {
            if (statusCheckInterval) {
                clearInterval(statusCheckInterval);
                statusCheckInterval = null;
            }
        }
        
        function updateProgress(progress, message) {
            const progressBar = document.getElementById('progressBar');
            progressBar.style.width = `${progress}%`;
            progressBar.textContent = `${progress}%`;
            document.getElementById('progressMessage').textContent = message;
        }
        
        // ============================================================
        // 취소
        // ============================================================
        async function cancelExtraction() {
            if (!currentTaskId) return;
            
            stopStatusCheck();
            
            try {
                await fetch(`/api/cancel/${currentTaskId}`, { method: 'POST' });
            } catch (error) {
                console.error('Cancel error:', error);
            }
            
            currentTaskId = null;
            resetAll();
        }
        
        // ============================================================
        // 완료 및 다운로드
        // ============================================================
        function showComplete() {
            document.getElementById('extractingSection').classList.remove('show');
            document.getElementById('completeSection').classList.add('show');
            
            // 미리보기 표시
            if (previewData) {
                showPreviewTab('vcm');  // 기본으로 VCM 포맷 표시
            } else {
                document.getElementById('previewContent').innerHTML = 
                    '<p class="preview-placeholder">미리보기 데이터가 없습니다.</p>';
            }
        }
        
        function showPreviewTab(tabName) {
            // 탭 버튼 활성화 상태 변경
            document.querySelectorAll('.preview-tab').forEach(tab => {
                tab.classList.remove('active');
                if (tab.dataset.tab === tabName) {
                    tab.classList.add('active');
                }
            });
            
            const content = document.getElementById('previewContent');
            
            // VCM 전용 포맷
            if (tabName === 'vcm') {
                content.innerHTML = renderVCMFormat();
                return;
            }
            
            // 미리보기 데이터 표시
            if (!previewData || !previewData[tabName]) {
                const tabNames = { 'bs': '재무상태표', 'is': '손익계산서', 'cf': '현금흐름표' };
                content.innerHTML = `<p class="preview-placeholder">${tabNames[tabName]} 데이터가 없습니다.</p>`;
                return;
            }
            
            const data = previewData[tabName];
            if (data.length === 0) {
                content.innerHTML = '<p class="preview-placeholder">데이터가 없습니다.</p>';
                return;
            }
            
            // 테이블 생성 - 필요한 컬럼만 표시 (계정과목 + 분류2~4 + FY 연도)
            const allHeaders = Object.keys(data[0]);
            // 계정과목, 분류2~4, FY 연도 컬럼만 필터링 (분류1 제외)
            const headers = allHeaders.filter(h => 
                h === '계정과목' || 
                (h.startsWith('분류') && h !== '분류1') || 
                h.startsWith('FY')
            );
            // 정렬: 계정과목 -> 분류1~4 -> FY 연도(오름차순, 최신이 우측)
            headers.sort((a, b) => {
                if (a === '계정과목') return -1;
                if (b === '계정과목') return 1;
                if (a.startsWith('분류') && !b.startsWith('분류')) return -1;
                if (!a.startsWith('분류') && b.startsWith('분류')) return 1;
                return a.localeCompare(b);
            });
            
            let tableHtml = '<p class="preview-unit">(단위: 백만원)</p>';
            tableHtml += '<table class="preview-table"><thead><tr>';
            headers.forEach(h => {
                tableHtml += `<th>${h}</th>`;
            });
            tableHtml += '</tr></thead><tbody>';
            
            data.forEach(row => {
                tableHtml += '<tr>';
                headers.forEach((h, idx) => {
                    let value = row[h];
                    // 숫자 포맷팅 (첫번째 열(계정과목)은 제외)
                    if (idx > 0 && typeof value === 'number') {
                        // 백만 단위로 변환 후 3자리마다 쉼표
                        const inMillions = Math.round(value / 1000000);
                        value = inMillions.toLocaleString();
                    } else if (idx > 0 && typeof value === 'string' && /^-?\d+$/.test(value.replace(/,/g, ''))) {
                        // 문자열 숫자도 처리
                        const numValue = parseInt(value.replace(/,/g, ''));
                        const inMillions = Math.round(numValue / 1000000);
                        value = inMillions.toLocaleString();
                    }
                    tableHtml += `<td>${value !== null && value !== undefined ? value : ''}</td>`;
                });
                tableHtml += '</tr>';
            });
            
            tableHtml += '</tbody></table>';
            tableHtml += '<p class="preview-info">* 처음 20행만 표시됩니다. 전체 데이터는 엑셀 파일을 다운로드하세요.</p>';
            
            content.innerHTML = tableHtml;
        }

        // ============================================================
        // VCM 전용 포맷 렌더링
        // ============================================================
        function renderVCMFormat() {
            if (!previewData) {
                return '<p class="preview-placeholder">데이터가 없습니다.</p>';
            }

            // 연도 컬럼 추출 (FY로 시작하는 컬럼)
            const bsData = previewData.bs || [];
            // CIS 우선 (HTML 주석 병합 데이터), 없으면 IS 사용
            const isData = previewData.cis || previewData.is || [];
            
            // 디버깅: 실제 데이터 구조 확인
            console.log('=== VCM 디버깅 ===');
            console.log('IS 데이터 행 수:', isData.length);
            if (isData.length > 0) {
                console.log('=== IS(손익계산서) 전체 계정과목 목록 ===');
                isData.forEach((r, i) => {
                    console.log(`[${i}] ${r['계정과목']}`);
                });
                console.log('=== IS 계정과목 총 개수:', isData.length, '===');
            }
            
            let years = [];
            if (bsData.length > 0) {
                years = Object.keys(bsData[0]).filter(k => k.startsWith('FY')).sort();
            } else if (isData.length > 0) {
                years = Object.keys(isData[0]).filter(k => k.startsWith('FY')).sort();
            }
            
            // 최근 5년만 표시 (내림차순 정렬 후 상위 5개 선택, 다시 오름차순으로 표시)
            if (years.length > 5) {
                years = years.sort().reverse().slice(0, 5).reverse();
            }
            console.log('추출된 연도 (최근 5년):', years);
            
            if (years.length === 0) {
                return '<p class="preview-placeholder">연도 데이터가 없습니다.</p>';
            }
            
            // 동적 단위 결정: 원본 데이터에서 최대 절대값 확인
            // 최소 단위는 백만원, 필요시 억원/십억원으로 조정
            let maxAbsValue = 0;
            const allData = [...bsData, ...isData];
            allData.forEach(row => {
                years.forEach(y => {
                    const val = row[y];
                    if (typeof val === 'number' && !isNaN(val)) {
                        const absVal = Math.abs(val);
                        if (absVal > maxAbsValue) maxAbsValue = absVal;
                    }
                });
            });
            
            // 단위 결정 (원본 데이터 기준)
            // maxAbsValue는 원본 값 (원 단위, Excel raw 데이터)
            // 최대값에 따라 적절한 단위 자동 선택
            let unitDivisor = 1_000_000;  // 기본: 백만원
            let unitLabel = '백만원';

            if (maxAbsValue >= 1_000_000_000_000) {  // 1조 이상
                unitDivisor = 100_000_000;  // 억원
                unitLabel = '억원';
            } else if (maxAbsValue >= 100_000_000_000) {  // 천억(1,000억) 이상
                unitDivisor = 10_000_000;  // 천만원
                unitLabel = '천만원';
            } else if (maxAbsValue >= 10_000_000_000) {  // 백억(100억) 이상
                unitDivisor = 1_000_000;  // 백만원
                unitLabel = '백만원';
            }

            console.log('최대값(원):', maxAbsValue.toLocaleString(), '→ 단위:', unitLabel);
            
            // 계정과목명 정규화 함수 (로마숫자, 주석번호 제거)
            function normalizeAccount(str) {
                if (!str) return '';
                return str
                    .replace(/\s/g, '')           // 공백 제거
                    .replace(/^[ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩ]+\./g, '')  // 로마숫자 접두어 제거
                    .replace(/\(주석[0-9,]+\)/g, '')   // 주석번호 제거
                    .replace(/\(손실\)/g, '')     // (손실) 제거
                    .replace(/등$/g, '비용');     // "법인세등" -> "법인세비용"
            }
            
            // 값 파싱 헬퍼 함수 (동적 단위 적용)
            function parseValue(val) {
                if (val === null || val === undefined) return null;
                if (typeof val === 'number') return val / unitDivisor;  // 반올림 제거, 정밀한 값 유지

                const str = String(val).trim();
                if (str === '' || str === '-' || str === 'nan' || str === 'NaN') return null;

                // 괄호로 표시된 음수 처리: (1,000,000) -> -1000000
                let isNegative = false;
                let cleanStr = str;
                if (str.startsWith('(') && str.endsWith(')')) {
                    isNegative = true;
                    cleanStr = str.slice(1, -1);
                }

                // 쉼표 제거 후 숫자 변환
                const num = parseFloat(cleanStr.replace(/,/g, ''));
                if (isNaN(num)) return null;

                return (isNegative ? -num : num) / unitDivisor;  // 반올림 제거, 정밀한 값 유지
            }

            // 자동 단위 감지 값 파싱 (손익계산서 전용 - 원/천원 혼재 대응)
            // 100,000,000 이상이면 원 단위, 미만이면 천원 단위로 간주
            function parseValueWithAutoUnit(val) {
                if (val === null || val === undefined) return null;

                let num;
                if (typeof val === 'number') {
                    num = val;
                } else {
                    const str = String(val).trim();
                    if (str === '' || str === '-' || str === 'nan' || str === 'NaN') return null;

                    // 괄호로 표시된 음수 처리
                    let isNegative = false;
                    let cleanStr = str;
                    if (str.startsWith('(') && str.endsWith(')')) {
                        isNegative = true;
                        cleanStr = str.slice(1, -1);
                    }

                    // 쉼표 제거 후 숫자 변환
                    num = parseFloat(cleanStr.replace(/,/g, ''));
                    if (isNaN(num)) return null;

                    if (isNegative) num = -num;
                }

                // 자동 단위 감지: 100,000,000 (1억) 이상이면 원 단위, 미만이면 천원 단위
                if (Math.abs(num) >= 100000000) {
                    return num / 100000000;  // 원 -> 억원
                } else {
                    return num / 100000;  // 천원 -> 억원
                }
            }

            // 자동 단위 감지를 적용한 findValue (손익계산서 전용)
            function findValueIS(data, keywords, year, excludeKeywords = []) {
                if (!keywords || keywords.length === 0) return null;

                // 1차: 정확한 매칭 시도
                for (const row of data) {
                    const accountRaw = row['계정과목'] || '';
                    const account = normalizeAccount(accountRaw);

                    // 제외 키워드 체크
                    let excluded = false;
                    for (const ex of excludeKeywords) {
                        if (account.includes(normalizeAccount(ex))) {
                            excluded = true;
                            break;
                        }
                    }
                    if (excluded) continue;

                    for (const kw of keywords) {
                        const kwNorm = normalizeAccount(kw);
                        if (account === kwNorm || account.startsWith(kwNorm)) {
                            const val = parseValue(row[year]);
                            if (val !== null) return val;
                        }
                    }
                }

                // 2차: 포함 매칭 시도
                for (const row of data) {
                    const accountRaw = row['계정과목'] || '';
                    const account = normalizeAccount(accountRaw);

                    // 제외 키워드 체크
                    let excluded = false;
                    for (const ex of excludeKeywords) {
                        if (account.includes(normalizeAccount(ex))) {
                            excluded = true;
                            break;
                        }
                    }
                    if (excluded) continue;

                    for (const kw of keywords) {
                        if (account.includes(normalizeAccount(kw))) {
                            const val = parseValue(row[year]);
                            if (val !== null) return val;
                        }
                    }
                }

                return null;
            }
            
            // 분류3(유동부채/비유동부채 등)를 고려한 검색 함수
            function findValueWithCategory(data, keywords, year, category3, excludeKeywords = []) {
                if (!keywords || keywords.length === 0) return null;

                for (const row of data) {
                    const accountRaw = row['계정과목'] || '';
                    const account = normalizeAccount(accountRaw);
                    const rowCategory3 = row['분류3'] || '';

                    // 분류3 체크 (지정된 경우만)
                    if (category3 && !rowCategory3.includes(category3)) continue;

                    // 제외 키워드 체크
                    let excluded = false;
                    for (const ex of excludeKeywords) {
                        if (account.includes(normalizeAccount(ex))) {
                            excluded = true;
                            break;
                        }
                    }
                    if (excluded) continue;

                    for (const kw of keywords) {
                        const kwNorm = normalizeAccount(kw);
                        if (account === kwNorm || account.includes(kwNorm)) {
                            const val = parseValue(row[year]);
                            if (val !== null) return val;
                        }
                    }
                }
                return null;
            }

            // 데이터를 계정과목으로 검색하는 헬퍼 함수
            // debugMode: true면 매칭 실패시 로그 출력
            const debugFindValue = true;  // 디버그 모드 ON
            function findValue(data, keywords, year, excludeKeywords = []) {
                if (!keywords || keywords.length === 0) return null;
                
                // 1차: 정확한 매칭 시도
                for (const row of data) {
                    const accountRaw = row['계정과목'] || '';
                    const account = normalizeAccount(accountRaw);
                    
                    // 제외 키워드 체크
                    let excluded = false;
                    for (const ex of excludeKeywords) {
                        if (account.includes(normalizeAccount(ex))) {
                            excluded = true;
                            break;
                        }
                    }
                    if (excluded) continue;
                    
                    for (const kw of keywords) {
                        const kwNorm = normalizeAccount(kw);
                        // 정확한 매칭 (계정과목이 키워드와 동일하거나, 키워드로 시작)
                        if (account === kwNorm || account.startsWith(kwNorm)) {
                            const val = parseValue(row[year]);
                            if (val !== null) return val;
                        }
                    }
                }
                
                // 2차: 포함 매칭 시도 (정확한 매칭 실패 시)
                for (const row of data) {
                    const accountRaw = row['계정과목'] || '';
                    const account = normalizeAccount(accountRaw);
                    
                    // 제외 키워드 체크
                    let excluded = false;
                    for (const ex of excludeKeywords) {
                        if (account.includes(normalizeAccount(ex))) {
                            excluded = true;
                            break;
                        }
                    }
                    if (excluded) continue;
                    
                    for (const kw of keywords) {
                        if (account.includes(normalizeAccount(kw))) {
                            const val = parseValue(row[year]);
                            if (val !== null) return val;
                        }
                    }
                }
                
                // 디버그: 매칭 실패 로그
                if (debugFindValue && keywords.length > 0) {
                    console.log(`[findValue 실패] 키워드: [${keywords.join(', ')}], 연도: ${year}`);
                }
                return null;
            }
            
            // 숫자 포맷팅 (단위 무관, 1 미만은 소수점 2자리, 1 이상은 정수)
            function fmt(val) {
                if (val === null || val === undefined || isNaN(val)) return '';

                // 단위별 최소 표시 단위 (백만원 기준)
                // 백만원 단위: 1 = 백만원 → 정수만
                // 천만원 단위: 0.1 = 백만원 → 소수점 첫째 자리
                // 억원 단위: 0.01 = 백만원 → 소수점 둘째 자리
                let minDisplayValue, decimalPlaces;

                if (unitLabel === '백만원') {
                    minDisplayValue = 1;      // 백만원 미만은 표시 안 함
                    decimalPlaces = 0;        // 정수만
                } else if (unitLabel === '천만원') {
                    minDisplayValue = 0.1;    // 백만원 미만은 표시 안 함
                    decimalPlaces = 1;        // 소수점 첫째 자리까지
                } else {  // 억원
                    minDisplayValue = 0.01;   // 백만원 미만은 표시 안 함
                    decimalPlaces = 2;        // 소수점 둘째 자리까지
                }

                if (Math.abs(val) < minDisplayValue) return '';  // 최소 단위 미만은 빈칸

                // 100 이상: 항상 정수로 표시
                if (Math.abs(val) >= 100) {
                    return Math.round(val).toLocaleString();
                }

                // 소수점 반올림 후 trailing zero 제거
                const rounded = parseFloat(val.toFixed(decimalPlaces));
                const formatted = rounded.toLocaleString('en-US', {
                    minimumFractionDigits: 0,
                    maximumFractionDigits: decimalPlaces
                });

                return formatted;
            }
            
            function pct(val, base) {
                if (!base || !val || isNaN(val) || isNaN(base)) return '';
                return (val / base * 100).toFixed(1) + '%';
            }
            
            // 재무상태표 항목 정의 (excludes: 제외할 키워드)
            // 실제 계정과목명: 'Ⅰ.유동자산', '현금및현금성자산(주석3,19)', '자 산 총 계' 등

            // VCM 데이터에서 부모 항목의 세부항목 찾기 (툴팁용)
            function getVcmBreakdown(parentItem, year, vcmData) {
                const breakdown = [];
                if (!vcmData || !Array.isArray(vcmData)) return breakdown;

                // '부모' 컬럼이 parentItem인 항목들 찾기
                vcmData.forEach(row => {
                    const parent = row['부모'];
                    const item = row['항목'];
                    const val = row[year];

                    if (parent === parentItem && val !== null && val !== undefined && val !== 0) {
                        breakdown.push({
                            name: item,
                            value: parseFloat(val) || 0
                        });
                    }
                });

                return breakdown;
            }

            // 합산 항목의 상세 breakdown 반환 (툴팁용) - VCM 우선, 없으면 기존 로직
            function getBsBreakdown(calcType, year, vcmData) {
                // VCM 데이터에서 세부항목 찾기 시도
                if (vcmData && Array.isArray(vcmData)) {
                    let parentItem = null;
                    switch(calcType) {
                        case 'tradeReceivables': parentItem = '매출채권및기타채권'; break;
                        case 'currentTradePayables': parentItem = '매입채무및기타채무'; break;
                        case 'nonCurrentTradePayables': parentItem = '매입채무및기타채무[비유동]'; break;
                        case 'otherEquity': parentItem = '기타자본구성요소'; break;
                        case 'longTermInvestments': parentItem = '장기투자자산'; break;
                        case 'otherCurrentLiabilities': parentItem = '기타유동부채'; break;
                    }

                    if (parentItem) {
                        const vcmBreakdown = getVcmBreakdown(parentItem, year, vcmData);
                        if (vcmBreakdown.length > 0) {
                            return vcmBreakdown;
                        }
                    }
                }

                // VCM에 없으면 기존 로직 사용
                const breakdown = [];
                switch(calcType) {
                    case 'tradeReceivables':
                        // 세부 항목이 있으면 표시 (통합 계정명 사용 여부와 무관)
                        const 매출채권 = findValue(bsData, ['매출채권'], year, ['대손', '처분']) || 0;
                        const 미수금 = findValue(bsData, ['미수금'], year) || 0;
                        const 미수수익 = findValue(bsData, ['미수수익'], year) || 0;
                        if (매출채권) breakdown.push({ name: '매출채권', value: 매출채권 });
                        if (미수금) breakdown.push({ name: '미수금', value: 미수금 });
                        if (미수수익) breakdown.push({ name: '미수수익', value: 미수수익 });
                        break;
                    case 'otherCurrentAssets':
                        // 세부 항목이 있으면 표시 (통합 계정명 사용 여부와 무관)
                        const 선급금 = findValue(bsData, ['선급금'], year) || 0;
                        const 선급비용 = findValue(bsData, ['선급비용'], year) || 0;
                        if (선급금) breakdown.push({ name: '선급금', value: 선급금 });
                        if (선급비용) breakdown.push({ name: '선급비용', value: 선급비용 });
                        break;
                    case 'tradePayables': {
                        const 매입채무 = findValue(bsData, ['매입채무'], year) || 0;
                        const 미지급금 = findValue(bsData, ['미지급금'], year, ['장기']) || 0;
                        const 미지급비용 = findValue(bsData, ['미지급비용'], year) || 0;
                        if (매입채무) breakdown.push({ name: '매입채무', value: 매입채무 });
                        if (미지급금) breakdown.push({ name: '미지급금', value: 미지급금 });
                        if (미지급비용) breakdown.push({ name: '미지급비용', value: 미지급비용 });
                        break;
                    }
                    case 'currentTradePayables':
                        // 유동 매입채무및기타채무: 통합 계정 또는 세부 항목들
                        const 유동미지급금통합 = findValueWithCategory(bsData, ['미지급금및기타채무'], year, '유동부채') || 0;
                        const 유동매입채무 = findValueWithCategory(bsData, ['매입채무'], year, '유동부채') || 0;
                        const 유동미지급금세부 = findValueWithCategory(bsData, ['미지급금'], year, '유동부채') || 0;
                        const 유동미지급비용 = findValueWithCategory(bsData, ['미지급비용'], year, '유동부채') || 0;
                        const 유동선수금 = findValueWithCategory(bsData, ['선수금'], year, '유동부채') || 0;

                        if (유동미지급금통합) breakdown.push({ name: '미지급금및기타채무', value: 유동미지급금통합 });
                        if (유동매입채무) breakdown.push({ name: '매입채무', value: 유동매입채무 });
                        if (유동미지급금세부) breakdown.push({ name: '미지급금', value: 유동미지급금세부 });
                        if (유동미지급비용) breakdown.push({ name: '미지급비용', value: 유동미지급비용 });
                        if (유동선수금) breakdown.push({ name: '선수금', value: 유동선수금 });
                        break;
                    case 'nonCurrentTradePayables':
                        // 비유동 매입채무및기타채무: 통합 계정 또는 세부 항목들
                        const 비유동미지급금통합 = findValueWithCategory(bsData, ['미지급금및기타채무'], year, '비유동부채') || 0;
                        const 비유동장기매입채무 = findValueWithCategory(bsData, ['장기매입채무', '매입채무'], year, '비유동부채') || 0;
                        const 비유동장기미지급금 = findValueWithCategory(bsData, ['장기미지급금'], year, '비유동부채') || 0;
                        const 비유동장기미지급비용 = findValueWithCategory(bsData, ['장기미지급비용'], year, '비유동부채') || 0;
                        const 비유동장기선수금 = findValueWithCategory(bsData, ['장기선수금'], year, '비유동부채') || 0;
                        const 비유동장기선수수익 = findValueWithCategory(bsData, ['장기선수수익'], year, '비유동부채') || 0;
                        const 비유동장기예수금 = findValueWithCategory(bsData, ['장기예수금'], year, '비유동부채') || 0;
                        const 비유동임대보증금 = findValueWithCategory(bsData, ['임대보증금', '장기예수보증금'], year, '비유동부채') || 0;

                        if (비유동미지급금통합) breakdown.push({ name: '미지급금및기타채무', value: 비유동미지급금통합 });
                        if (비유동장기매입채무) breakdown.push({ name: '장기매입채무', value: 비유동장기매입채무 });
                        if (비유동장기미지급금) breakdown.push({ name: '장기미지급금', value: 비유동장기미지급금 });
                        if (비유동장기미지급비용) breakdown.push({ name: '장기미지급비용', value: 비유동장기미지급비용 });
                        if (비유동장기선수금) breakdown.push({ name: '장기선수금', value: 비유동장기선수금 });
                        if (비유동장기선수수익) breakdown.push({ name: '장기선수수익', value: 비유동장기선수수익 });
                        if (비유동장기예수금) breakdown.push({ name: '장기예수금', value: 비유동장기예수금 });
                        if (비유동임대보증금) breakdown.push({ name: '임대보증금', value: 비유동임대보증금 });
                        break;
                    case 'otherCurrentLiab':
                        const 수탁금 = findValue(bsData, ['수탁금및기타부채'], year) || 0;
                        const 유동리스 = findValue(bsData, ['유동리스부채'], year) || 0;
                        const 선수금 = findValue(bsData, ['선수금'], year) || 0;
                        const 예수금 = findValue(bsData, ['예수금'], year) || 0;
                        const 선수수익 = findValue(bsData, ['선수수익'], year) || 0;
                        if (수탁금) breakdown.push({ name: '수탁금및기타부채', value: 수탁금 });
                        if (유동리스) breakdown.push({ name: '유동리스부채', value: 유동리스 });
                        if (선수금) breakdown.push({ name: '선수금', value: 선수금 });
                        if (예수금) breakdown.push({ name: '예수금', value: 예수금 });
                        if (선수수익) breakdown.push({ name: '선수수익', value: 선수수익 });
                        break;
                    case 'currentLongTermDebt':
                        const 유동성장기차입금_항목 = findValueWithCategory(bsData, ['유동성장기차입금'], year, '유동부채') || 0;
                        const 유동성장기부채_항목 = findValueWithCategory(bsData, ['유동성장기부채'], year, '유동부채') || 0;
                        if (유동성장기차입금_항목) breakdown.push({ name: '유동성장기차입금', value: 유동성장기차입금_항목 });
                        if (유동성장기부채_항목) breakdown.push({ name: '유동성장기부채', value: 유동성장기부채_항목 });
                        break;
                    case 'currentBonds':
                        const 전환유동 = findValueWithCategory(bsData, ['전환사채'], year, '유동부채') || 0;
                        const 신주유동 = findValueWithCategory(bsData, ['신주인수권부사채'], year, '유동부채') || 0;
                        const 유동사채 = findValueWithCategory(bsData, ['유동성사채', '1년내상환사채', '단기사채'], year, '유동부채') || 0;
                        if (전환유동) breakdown.push({ name: '전환사채', value: 전환유동 });
                        if (신주유동) breakdown.push({ name: '신주인수권부사채', value: 신주유동 });
                        if (유동사채) breakdown.push({ name: '유동성사채', value: 유동사채 });
                        break;
                    case 'nonCurrentBonds':
                        const 사채비유동 = findValueWithCategory(bsData, ['사채'], year, '비유동부채', ['유동성', '차입금']) || 0;
                        const 전환비유동 = findValueWithCategory(bsData, ['전환사채'], year, '비유동부채') || 0;
                        const 신주비유동 = findValueWithCategory(bsData, ['신주인수권부사채'], year, '비유동부채') || 0;
                        if (사채비유동) breakdown.push({ name: '사채', value: 사채비유동 });
                        if (전환비유동) breakdown.push({ name: '전환사채', value: 전환비유동 });
                        if (신주비유동) breakdown.push({ name: '신주인수권부사채', value: 신주비유동 });
                        break;
                    case 'longTermDebt':
                        const 장기차입금_항목 = findValueWithCategory(bsData, ['장기차입금'], year, '비유동부채', ['유동성', '사채']) || 0;
                        if (장기차입금_항목) breakdown.push({ name: '장기차입금', value: 장기차입금_항목 });
                        break;
                    case 'otherEquity':
                        // 기타자본구성요소 = 자본잉여금 + 기타자본 + 기타포괄손익누계액 + 재평가잉여금
                        const 자본잉여금 = findValue(bsData, ['자본잉여금'], year) || 0;
                        const 기타자본 = findValue(bsData, ['기타자본', '기타자본항목'], year) || 0;
                        const 기타포괄손익 = findValue(bsData, ['기타포괄손익누계액'], year) || 0;
                        const 재평가잉여금 = findValue(bsData, ['재평가잉여금'], year) || 0;
                        if (자본잉여금) breakdown.push({ name: '자본잉여금', value: 자본잉여금 });
                        if (기타자본) breakdown.push({ name: '기타자본', value: 기타자본 });
                        if (기타포괄손익) breakdown.push({ name: '기타포괄손익누계액', value: 기타포괄손익 });
                        if (재평가잉여금) breakdown.push({ name: '재평가잉여금', value: 재평가잉여금 });
                        break;
                    case 'longTermInvestments':
                        // 장기투자자산 = 장기금융상품 + 장기투자증권 + 관계기업투자
                        const 장기금융상품 = findValue(bsData, ['장기금융상품'], year) || 0;
                        const 장기투자증권 = findValue(bsData, ['장기투자증권', '매도가능증권', '기타포괄손익공정가치측정금융자산', 'FVOCI금융자산'], year) || 0;
                        const 관계기업투자 = findValue(bsData, ['관계기업투자', '종속기업투자', '지분법적용투자주식'], year) || 0;
                        if (장기금융상품) breakdown.push({ name: '장기금융상품', value: 장기금융상품 });
                        if (장기투자증권) breakdown.push({ name: '장기투자증권', value: 장기투자증권 });
                        if (관계기업투자) breakdown.push({ name: '관계기업투자', value: 관계기업투자 });
                        break;
                }
                return breakdown;
            }

            // 재무상태표 합산 계산 함수
            function calcBsValue(calcType, year) {
                switch(calcType) {
                    case 'tradeReceivables':
                        // 매출채권및기타채권: 통합 항목 우선, 없으면 개별 항목 합산
                        const 통합매출채권 = findValue(bsData, ['매출채권및기타채권', '매출채권및기타유동채권'], year);
                        if (통합매출채권) {
                            return 통합매출채권;
                        }
                        // 개별 항목 합산
                        const 매출채권 = findValue(bsData, ['매출채권'], year, ['대손', '처분']) || 0;
                        const 미수금 = findValue(bsData, ['미수금'], year) || 0;
                        const 미수수익 = findValue(bsData, ['미수수익'], year) || 0;
                        return 매출채권 + 미수금 + 미수수익;
                    case 'otherCurrentAssets':
                        // 기타비금융자산: 통합 항목 우선, 없으면 개별 항목 합산
                        const 통합기타자산 = findValue(bsData, ['기타자산', '기타유동자산'], year, ['비유동']);
                        if (통합기타자산) {
                            return 통합기타자산;
                        }
                        // 개별 항목 합산
                        const 선급금 = findValue(bsData, ['선급금'], year) || 0;
                        const 선급비용 = findValue(bsData, ['선급비용'], year) || 0;
                        return 선급금 + 선급비용;
                    case 'tradePayables': {
                        // 매입채무및기타채무 = 매입채무 + 미지급금 + 미지급비용
                        const 매입채무 = findValue(bsData, ['매입채무'], year) || 0;
                        const 미지급금 = findValue(bsData, ['미지급금'], year, ['장기']) || 0;
                        const 미지급비용 = findValue(bsData, ['미지급비용'], year) || 0;
                        return 매입채무 + 미지급금 + 미지급비용;
                    }
                    case 'otherCurrentLiab':
                        // 기타유동부채 = 수탁금및기타부채 + 유동리스부채 + 선수금 + 예수금 + 선수수익 등
                        const 수탁금및기타부채 = findValue(bsData, ['수탁금및기타부채'], year) || 0;
                        const 유동리스부채 = findValue(bsData, ['유동리스부채'], year) || 0;
                        const 선수금 = findValue(bsData, ['선수금'], year) || 0;
                        const 예수금 = findValue(bsData, ['예수금'], year) || 0;
                        const 선수수익 = findValue(bsData, ['선수수익'], year) || 0;
                        const 기타유동부채 = findValue(bsData, ['기타유동부채'], year) || 0;
                        return 수탁금및기타부채 + 유동리스부채 + 선수금 + 예수금 + 선수수익 + 기타유동부채;
                    case 'currentLongTermDebt':
                        // 유동성장기차입금 = 유동성장기차입금 + 유동성장기부채
                        const 유동성장기차입금 = findValueWithCategory(bsData, ['유동성장기차입금'], year, '유동부채') || 0;
                        const 유동성장기부채 = findValueWithCategory(bsData, ['유동성장기부채'], year, '유동부채') || 0;
                        return 유동성장기차입금 + 유동성장기부채;
                    case 'currentBonds':
                        // 유동성사채 = 유동부채의 (전환사채 + 신주인수권부사채 + 유동성사채)
                        const 전환사채_유동 = findValueWithCategory(bsData, ['전환사채'], year, '유동부채') || 0;
                        const 신주인수권부사채_유동 = findValueWithCategory(bsData, ['신주인수권부사채'], year, '유동부채') || 0;
                        const 유동성사채 = findValueWithCategory(bsData, ['유동성사채', '1년내상환사채', '단기사채', '유동사채'], year, '유동부채') || 0;
                        return 전환사채_유동 + 신주인수권부사채_유동 + 유동성사채;
                    case 'nonCurrentBonds':
                        // 비유동 사채 = 비유동부채의 (사채 + 전환사채 + 신주인수권부사채)
                        // '차입금' 제외 - "장기차입금(사채 포함)"과 같은 통합 항목 제외
                        const 사채_비유동 = findValueWithCategory(bsData, ['사채'], year, '비유동부채', ['유동성', '차입금']) || 0;
                        const 전환사채_비유동 = findValueWithCategory(bsData, ['전환사채'], year, '비유동부채') || 0;
                        const 신주인수권부사채_비유동 = findValueWithCategory(bsData, ['신주인수권부사채'], year, '비유동부채') || 0;
                        return 사채_비유동 + 전환사채_비유동 + 신주인수권부사채_비유동;
                    case 'longTermDebt':
                        // 장기차입금 = 비유동부채의 장기차입금
                        // '사채' 제외 - "장기차입금(사채 포함)"과 같은 통합 항목 제외
                        const 장기차입금 = findValueWithCategory(bsData, ['장기차입금'], year, '비유동부채', ['유동성', '사채']) || 0;
                        return 장기차입금;
                    case 'currentTradePayables': {
                        // 유동 매입채무및기타채무: 통합 항목 우선, 없으면 개별 항목 합산
                        const 통합유동매입채무 = findValueWithCategory(bsData, ['미지급금및기타채무'], year, '유동부채');
                        if (통합유동매입채무) {
                            console.log(`[유동 매입채무및기타채무] ${year}: ${통합유동매입채무} (통합항목)`);
                            return 통합유동매입채무;
                        }
                        // 개별 항목 합산 (넥시스 등)
                        const 매입채무 = findValueWithCategory(bsData, ['매입채무'], year, '유동부채') || 0;
                        const 미지급금 = findValueWithCategory(bsData, ['미지급금'], year, '유동부채') || 0;
                        const 미지급비용 = findValueWithCategory(bsData, ['미지급비용'], year, '유동부채') || 0;
                        const 선수금 = findValueWithCategory(bsData, ['선수금'], year, '유동부채') || 0;
                        const 선수수익 = findValueWithCategory(bsData, ['선수수익'], year, '유동부채') || 0;
                        const 예수금 = findValueWithCategory(bsData, ['예수금'], year, '유동부채') || 0;
                        const 예수보증금 = findValueWithCategory(bsData, ['예수보증금'], year, '유동부채') || 0;
                        const 연차충당부채 = findValueWithCategory(bsData, ['연차충당부채'], year, '유동부채') || 0;
                        const 개별합계 = 매입채무 + 미지급금 + 미지급비용 + 선수금 + 선수수익 + 예수금 + 예수보증금 + 연차충당부채;
                        console.log(`[유동 매입채무및기타채무] ${year}: ${개별합계} (개별합산: 매입${매입채무}+미지급금${미지급금}+미지급비용${미지급비용}+선수금${선수금}+선수수익${선수수익}+예수금${예수금}+예수보증금${예수보증금}+연차${연차충당부채})`);
                        return 개별합계;
                    }
                    case 'nonCurrentTradePayables': {
                        // 비유동 매입채무및기타채무: 통합 항목 우선, 없으면 개별 항목 합산
                        const 통합비유동매입채무 = findValueWithCategory(bsData, ['미지급금및기타채무'], year, '비유동부채');
                        if (통합비유동매입채무) {
                            console.log(`[비유동 매입채무및기타채무] ${year}: ${통합비유동매입채무} (통합항목)`);
                            return 통합비유동매입채무;
                        }
                        // 개별 항목 합산 (유동부채와 동일한 논리)
                        const 장기매입채무 = findValueWithCategory(bsData, ['매입채무', '장기매입채무'], year, '비유동부채') || 0;
                        const 장기미지급금 = findValueWithCategory(bsData, ['장기미지급금'], year, '비유동부채') || 0;
                        const 장기미지급비용 = findValueWithCategory(bsData, ['장기미지급비용'], year, '비유동부채') || 0;
                        const 장기선수금 = findValueWithCategory(bsData, ['장기선수금'], year, '비유동부채') || 0;
                        const 장기선수수익 = findValueWithCategory(bsData, ['장기선수수익'], year, '비유동부채') || 0;
                        const 장기예수금 = findValueWithCategory(bsData, ['장기예수금'], year, '비유동부채') || 0;
                        const 임대보증금 = findValueWithCategory(bsData, ['임대보증금', '장기예수보증금'], year, '비유동부채') || 0;
                        const 비유동개별합계 = 장기매입채무 + 장기미지급금 + 장기미지급비용 + 장기선수금 + 장기선수수익 + 장기예수금 + 임대보증금;
                        console.log(`[비유동 매입채무및기타채무] ${year}: ${비유동개별합계} (개별합산: 장기매입${장기매입채무}+장기미지급금${장기미지급금}+장기미지급비용${장기미지급비용}+장기선수금${장기선수금}+장기선수수익${장기선수수익}+장기예수금${장기예수금}+임대보증금${임대보증금})`);
                        return 비유동개별합계;
                    }
                    case 'otherEquity':
                        // 기타자본구성요소 = 자본잉여금 + 기타자본 + 기타포괄손익누계액 + 재평가잉여금
                        const 자본잉여금 = findValue(bsData, ['자본잉여금'], year) || 0;
                        const 기타자본 = findValue(bsData, ['기타자본', '기타자본항목'], year) || 0;
                        const 기타포괄손익 = findValue(bsData, ['기타포괄손익누계액'], year) || 0;
                        const 재평가잉여금 = findValue(bsData, ['재평가잉여금'], year) || 0;
                        return 자본잉여금 + 기타자본 + 기타포괄손익 + 재평가잉여금;
                    case 'longTermInvestments':
                        // 장기투자자산 = 장기금융상품 + 장기투자증권 + 관계기업투자
                        // 통합 항목 우선 확인
                        const 장기투자자산통합 = findValue(bsData, ['장기투자자산', '투자자산'], year) || 0;
                        if (장기투자자산통합) return 장기투자자산통합;

                        // 개별 항목 합산
                        const 장기금융상품 = findValue(bsData, ['장기금융상품'], year) || 0;
                        const 장기투자증권 = findValue(bsData, ['장기투자증권', '매도가능증권', '기타포괄손익공정가치측정금융자산', 'FVOCI금융자산'], year) || 0;
                        const 관계기업투자 = findValue(bsData, ['관계기업투자', '종속기업투자', '지분법적용투자주식'], year) || 0;
                        return 장기금융상품 + 장기투자증권 + 관계기업투자;
                    default:
                        return null;
                }
            }

            // ========== 판관비 동적 항목 선택 (전체 연도 평균 기준) ==========
            function selectTopSgaItems(isData, years) {
                // 모든 가능한 판관비 항목 정의 (is_sum: true면 복수 키워드 합산)
                const sgaCandidates = {
                    '인건비': { keywords: [['급여'], ['퇴직급여'], ['복리후생비']], excludes: [['퇴직', '연차'], [], []], isSum: true },
                    '임차료비용': { keywords: [['지급임차료', '임차료']], excludes: [[]], isSum: false },
                    '수수료비용': { keywords: [['판매수수료'], ['지급수수료', '수수료']], excludes: [[], []], isSum: true },
                    '보험료': { keywords: [['보험료']], excludes: [[]], isSum: false },
                    '여비교통비': { keywords: [['여비교통비']], excludes: [[]], isSum: false },
                    '연구비': { keywords: [['경상연구개발비'], ['경상시험연구비'], ['연구개발비']], excludes: [[], [], []], isSum: true },
                    '감가상각비': { keywords: [['감가상각비']], excludes: [['무형']], isSum: false },
                    '무형자산상각비': { keywords: [['무형자산상각비']], excludes: [[]], isSum: false },
                    '접대비': { keywords: [['접대비']], excludes: [[]], isSum: false },
                    '통신비': { keywords: [['통신비']], excludes: [[]], isSum: false },
                    '세금과공과': { keywords: [['세금과공과']], excludes: [[]], isSum: false },
                    '차량유지비': { keywords: [['차량유지비']], excludes: [[]], isSum: false },
                    '운반비': { keywords: [['운반비']], excludes: [[]], isSum: false },
                    '교육훈련비': { keywords: [['교육훈련비']], excludes: [[]], isSum: false },
                    '도서인쇄비': { keywords: [['도서인쇄비']], excludes: [[]], isSum: false },
                    '사무용품비': { keywords: [['사무용품비']], excludes: [[]], isSum: false },
                    '소모품비': { keywords: [['소모품비']], excludes: [[]], isSum: false },
                    '보관료': { keywords: [['보관료']], excludes: [[]], isSum: false },
                    '광고선전비': { keywords: [['광고선전비']], excludes: [[]], isSum: false },
                    '판매촉진비': { keywords: [['판매촉진비']], excludes: [[]], isSum: false },
                    '건물관리비': { keywords: [['건물관리비']], excludes: [[]], isSum: false },
                    '대손상각비': { keywords: [['대손상각비']], excludes: [[]], isSum: false },
                    '협회비': { keywords: [['협회비']], excludes: [[]], isSum: false },
                    '사택관리비': { keywords: [['사택관리비']], excludes: [[]], isSum: false },
                    '폐기물처리비': { keywords: [['폐기물처리비']], excludes: [[]], isSum: false },
                    '주식보상비용': { keywords: [['주식보상비용']], excludes: [[]], isSum: false }
                };

                // 각 항목별로 전체 연도의 값을 수집
                const sgaItemValues = {};

                for (const [itemName, itemConfig] of Object.entries(sgaCandidates)) {
                    sgaItemValues[itemName] = [];

                    for (const year of years) {
                        let value = 0;

                        if (itemConfig.isSum) {
                            // 복수 키워드 합산
                            for (let i = 0; i < itemConfig.keywords.length; i++) {
                                const val = findValueIS(isData, itemConfig.keywords[i], year, itemConfig.excludes[i]) || 0;
                                value += val;
                            }
                        } else {
                            // 단일 키워드
                            value = findValueIS(isData, itemConfig.keywords[0], year, itemConfig.excludes[0]) || 0;
                        }

                        sgaItemValues[itemName].push(value);
                    }
                }

                // 각 항목의 평균 계산 및 정렬
                const sgaItemAverages = {};
                for (const [itemName, values] of Object.entries(sgaItemValues)) {
                    const sum = values.reduce((a, b) => a + b, 0);
                    const avg = values.length > 0 ? sum / values.length : 0;
                    sgaItemAverages[itemName] = avg;
                }

                // 평균 기준으로 내림차순 정렬
                const sortedSgaItems = Object.entries(sgaItemAverages)
                    .filter(([name, avg]) => avg > 0)  // 값이 있는 항목만
                    .sort((a, b) => b[1] - a[1]);  // 평균 내림차순

                // 상위 8개 항목 선택
                const topSgaItems = sortedSgaItems.slice(0, 8).map(([name]) => name);

                console.log('=== 동적 판관비 항목 선택 ===');
                console.log('선택된 항목 (상위 8개):', topSgaItems);
                sortedSgaItems.slice(0, 8).forEach(([name, avg]) => {
                    console.log(`  ${name}: 평균 ${avg.toFixed(2)}억원`);
                });

                return { topSgaItems, sgaCandidates, sgaItemValues };
            }

            // ========== 새로운 단순화된 렌더링 (vcm_display 사용) ==========
            const vcmDisplay = previewData?.vcm_display || [];
            const vcmMeta = previewData?.vcm || [];

            // vcm_display가 있으면 단순화된 렌더링 사용
            if (vcmDisplay.length > 0 && vcmMeta.length > 0) {
                console.log('[VCM] 단순화된 렌더링 사용 (vcm_display 기반)');

                // 타입 조회 헬퍼 (vcm 메타데이터에서)
                function getItemType(itemName) {
                    const meta = vcmMeta.find(r => r['항목'] === itemName);
                    return meta ? meta['타입'] : 'item';
                }

                // 부모 조회 헬퍼 (툴팁용)
                function getItemParent(itemName) {
                    const meta = vcmMeta.find(r => r['항목'] === itemName);
                    return meta ? meta['부모'] : '';
                }

                // 자식 항목들 조회 (툴팁용)
                function getChildItems(parentName, year) {
                    const children = vcmMeta.filter(r => r['부모'] === parentName);
                    return children.map(c => {
                        const displayRow = vcmDisplay.find(d => d['항목'] === c['항목']);
                        return {
                            name: c['항목'],
                            value: displayRow ? displayRow[year] : ''
                        };
                    }).filter(c => c.value && c.value !== '');
                }

                // 타입별 CSS 클래스
                function getRowClass(type) {
                    switch(type) {
                        case 'category': return 'category-row';
                        case 'total': return 'total-row';
                        case 'highlight': return 'total-row highlight-row';
                        case 'percent': return 'percent-row';
                        default: return '';
                    }
                }

                function getTdClass(type) {
                    return (type === 'subitem' || type === 'percent') ? 'sub-item' : '';
                }

                // 테이블 헤더 (단위: 천만원 - 백엔드에서 변환됨)
                let headerHtml = `<tr><th>(단위: 천만원)</th>`;
                years.forEach(y => { headerHtml += `<th>${y}</th>`; });
                headerHtml += '</tr>';

                // ========== 재무상태표 렌더링 ==========
                // 재무상태표: 유동자산 ~ 부채와자본총계 + NWC + Net Debt
                const bsEndItems = ['NWC', 'Net Debt'];  // 재무상태표 마지막에 포함될 항목
                const isStartNames = ['매출'];
                let bsTableHtml = '<table class="vcm-table"><thead>' + headerHtml + '</thead><tbody>';

                for (const row of vcmDisplay) {
                    const itemName = row['항목'];
                    if (!itemName) continue;

                    // 손익계산서 시작 지점 (매출)에서 BS 종료
                    if (itemName.trim() === '매출') break;

                    // NWC/Net Debt 하위항목은 제외 (툴팁에서만 표시)
                    if (itemName.includes('[NWC]') || itemName.includes('[NetDebt]')) continue;

                    const itemType = getItemType(itemName);
                    const rowClass = getRowClass(itemType);
                    const tdClass = getTdClass(itemType);

                    // 툴팁 생성 (자식 항목이 있으면)
                    let tooltip = '';
                    const parentName = itemName.trim();
                    const children = getChildItems(parentName, years[0]);
                    if (children.length > 0) {
                        tooltip = children.map(c => `${c.name}: ${c.value}`).join('\n');
                    }

                    bsTableHtml += `<tr class="${rowClass}"><td class="${tdClass}" title="${tooltip}">${itemName}</td>`;
                    years.forEach(y => {
                        let val = row[y];
                        // 숫자인 경우 천 단위 콤마 추가
                        if (typeof val === 'number' && !isNaN(val)) {
                            val = val.toLocaleString('ko-KR');
                        } else if (val === null || val === undefined) {
                            val = '';
                        }
                        bsTableHtml += `<td>${val}</td>`;
                    });
                    bsTableHtml += '</tr>';
                }
                bsTableHtml += '</tbody></table>';

                // ========== 손익계산서 렌더링 ==========
                let isTableHtml = '<table class="vcm-table"><thead>' + headerHtml + '</thead><tbody>';
                let foundIsStart = false;

                for (const row of vcmDisplay) {
                    const itemName = row['항목'];
                    if (!itemName) continue;

                    // IS 시작 지점 (매출부터)
                    if (itemName.trim() === '매출') foundIsStart = true;
                    if (!foundIsStart) continue;

                    // NWC, Net Debt 관련 항목은 재무상태표에 표시되므로 제외
                    if (itemName.includes('NWC') || itemName.includes('Net Debt')) continue;
                    if (itemName.includes('[NWC]') || itemName.includes('[NetDebt]')) continue;

                    const itemType = getItemType(itemName);
                    const rowClass = getRowClass(itemType);
                    const tdClass = getTdClass(itemType);

                    // 툴팁 생성 (자식 항목이 있으면)
                    let tooltip = '';
                    const parentName = itemName.trim();
                    const children = getChildItems(parentName, years[0]);
                    if (children.length > 0) {
                        tooltip = children.map(c => `${c.name}: ${c.value}`).join('\n');
                    }

                    isTableHtml += `<tr class="${rowClass}"><td class="${tdClass}" title="${tooltip}">${itemName}</td>`;
                    years.forEach(y => {
                        let val = row[y];
                        // 숫자인 경우 천 단위 콤마 추가
                        if (typeof val === 'number' && !isNaN(val)) {
                            val = val.toLocaleString('ko-KR');
                        } else if (val === null || val === undefined) {
                            val = '';
                        }
                        isTableHtml += `<td>${val}</td>`;
                    });
                    isTableHtml += '</tr>';
                }
                isTableHtml += '</tbody></table>';

                // 최종 HTML 반환 (기존 형식 유지)
                return `
                    <div class="vcm-container">
                        <div class="vcm-section">
                            <div class="vcm-title">재무상태표</div>
                            ${bsTableHtml}
                        </div>
                        <div class="vcm-section">
                            <div class="vcm-title">손익계산서</div>
                            ${isTableHtml}
                        </div>
                    </div>
                    <p class="preview-info">* Source: 전자공시시스템 (DART)</p>
                `;
            }

            // ========== 기존 복잡한 렌더링 (fallback) ==========
            console.log('[VCM] 기존 렌더링 사용 (vcm_display 없음)');

            // 동적 bsItems 생성 - VCM 데이터에서 직접 읽기
            const vcmData = previewData?.vcm || [];
            const bsItems = [];

            // VCM 데이터에서 재무상태표 항목만 추출 (NWC 이전까지)
            const categoryNames = ['유동자산', '비유동자산', '유동부채', '비유동부채'];
            const totalNames = ['자산총계', '부채총계', '자본총계', '부채와자본총계'];
            // 정확한 매칭으로 손익계산서 시작점 판단 (매출채권 등과 혼동 방지)
            const stopNames = ['NWC', 'Net Debt'];

            for (const row of vcmData) {
                const name = row['항목'];
                const parent = row['부모'];

                // NWC, Net Debt 이후는 손익계산서이므로 제외 (정확히 일치할 때만)
                if (stopNames.includes(name)) break;
                if (!name) continue;

                // 세부 항목 (부모가 있는 항목) - 테이블에서 제외, 툴팁에서만 사용
                if (parent && parent !== '') {
                    continue;  // 세부항목은 툴팁으로만 표시
                }

                // 카테고리 (유동자산, 비유동자산 등)
                if (categoryNames.includes(name)) {
                    bsItems.push({ name: name, isCategory: true, fromVcm: true });
                }
                // 총계 (자산총계, 부채총계 등)
                else if (totalNames.includes(name)) {
                    bsItems.push({ name: name, isTotal: true, fromVcm: true });
                }
                // 일반 항목
                else {
                    bsItems.push({ name: name, isSubItem: true, fromVcm: true });
                }
            }

            // VCM 데이터가 없으면 기본 구조 사용 (fallback)
            if (bsItems.length === 0) {
                bsItems.push(
                    { name: '유동자산', keywords: ['유동자산'], excludes: ['비유동'], isCategory: true },
                    { name: '현금및현금성자산', keywords: ['현금및현금성자산'], isSubItem: true },
                    { name: '비유동자산', keywords: ['비유동자산'], isCategory: true },
                    { name: '자산총계', keywords: ['자산총계'], isTotal: true },
                    { name: '유동부채', keywords: ['유동부채'], excludes: ['비유동'], isCategory: true },
                    { name: '비유동부채', keywords: ['비유동부채'], isCategory: true },
                    { name: '부채총계', keywords: ['부채총계'], isTotal: true },
                    { name: '자본총계', keywords: ['자본총계'], isTotal: true }
                );
            }

            console.log('[VCM] 동적 bsItems 생성:', bsItems.length, '개 항목');

            // 판관비 동적 항목 선택
            const { topSgaItems, sgaCandidates, sgaItemValues } = selectTopSgaItems(isData, years);

            // 손익계산서 항목 정의 (동적 생성)
            const isItems = [
                { name: '매출', calc: 'revenue', isCategory: true },
                { name: '상품매출', keywords: ['상품매출액', '상품매출'], excludes: ['원가'], isSubItem: true },
                { name: '제품매출', keywords: ['제품매출액', '제품매출'], excludes: ['원가'], isSubItem: true },
                { name: '기타매출', keywords: ['기타매출액', '기타매출'], excludes: ['원가'], isSubItem: true },
                { name: '매출원가', calc: 'cogs', isCategory: true },
                { name: '상품매출원가', keywords: ['상품매출원가'], isSubItem: true },
                { name: '제품매출원가', keywords: ['제품매출원가'], isSubItem: true },
                { name: '매출총이익', calc: 'grossProfit', isTotal: true },
                { name: '판매비와관리비', calc: 'sga', isCategory: true }
            ];

            // 동적 판관비 항목 추가 (상위 8개)
            for (const itemName of topSgaItems) {
                isItems.push({ name: itemName, calc: `dynamic_sga_${itemName}`, isSubItem: true });
            }

            // 기타판매비와관리비 항상 마지막에 추가
            isItems.push({ name: '기타판매비와관리비', calc: 'otherSga', isSubItem: true });

            // 나머지 손익계산서 항목 추가
            isItems.push(
                { name: '영업이익', calc: 'operatingIncome', isTotal: true, isHighlight: true },
                { name: '영업외수익', calc: 'otherIncome', isSubItem: true },
                { name: '금융수익', calc: 'financeIncome', isSubItem: true },
                { name: '영업외비용', calc: 'otherExpense', isSubItem: true },
                { name: '금융비용', calc: 'financeCost', isSubItem: true },
                { name: '법인세비용차감전이익', calc: 'ebt', isSubItem: true },
                { name: '법인세비용', calc: 'tax', isSubItem: true },
                { name: '당기순이익', calc: 'netIncome', isTotal: true, isHighlight: true }
            );
            
            // 테이블 헤더 생성 (동적 단위 표시)
            let headerHtml = `<tr><th>(단위: ${unitLabel})</th>`;
            years.forEach(y => { headerHtml += `<th>${y}</th>`; });
            headerHtml += '</tr>';
            
            // 재무상태표 테이블 생성
            let bsTableHtml = '<table class="vcm-table"><thead>' + headerHtml + '</thead><tbody>';
            bsItems.forEach(item => {
                // 빈 행 필터링: 모든 연도에 값이 없으면 건너뜀
                const vcmDataList = previewData?.vcm || [];
                const hasAnyValue = years.some(y => {
                    if (item.fromVcm) {
                        const vcmRow = vcmDataList.find(row => row['항목'] === item.name);
                        if (vcmRow && vcmRow[y] !== null && vcmRow[y] !== undefined && vcmRow[y] !== 0) return true;
                    }
                    if (item.calc) {
                        const calcVal = calcBsValue(item.calc, y);
                        if (calcVal !== null && calcVal !== undefined && calcVal !== 0) return true;
                    }
                    return false;
                });

                // 카테고리 행(자산, 부채 등 대분류)은 항상 표시, 나머지는 값이 있을 때만 표시
                if (!item.isCategory && !item.isTotal && !hasAnyValue) {
                    return; // 빈 행 건너뜀
                }

                let rowClass = item.isCategory ? 'category-row' : (item.isTotal ? 'total-row' : '');
                let tdClass = item.isSubItem ? 'sub-item' : '';

                // 합산 항목은 셀 배경색으로 표시
                bsTableHtml += `<tr class="${rowClass}"><td class="${tdClass} account-name">${item.name}</td>`;
                years.forEach(y => {
                    let val;
                    let tooltip = '';
                    let isMultipleItems = false;

                    // VCM 데이터에서 값 찾기
                    const vcmDataList = previewData?.vcm || [];

                    // VCM 동적 항목인 경우 직접 매칭
                    if (item.fromVcm) {
                        const vcmRow = vcmDataList.find(row => row['항목'] === item.name);
                        if (vcmRow && vcmRow[y] !== null && vcmRow[y] !== undefined) {
                            val = parseValue(vcmRow[y]);

                            // 세부 항목 툴팁 생성 (부모가 이 항목인 행들)
                            const children = vcmDataList.filter(row => row['부모'] === item.name);
                            if (children.length > 0) {
                                const childValues = children
                                    .filter(c => c[y] !== null && c[y] !== undefined)
                                    .map(c => `${c['항목']}: ${fmt(parseValue(c[y]))}`);
                                if (childValues.length > 0) {
                                    tooltip = `[${y} 세부내역]\n${childValues.join('\n')}`;
                                    isMultipleItems = true;
                                }
                            }
                        }
                        bsTableHtml += `<td class="${isMultipleItems ? 'calc-cell' : ''}" title="${tooltip}">${fmt(val)}</td>`;
                        return; // 다음 연도로
                    }

                    // 기존 로직 (fromVcm이 아닌 경우)
                    const vcmItemName = item.name === '매입채무및기타채무' ?
                        (rowClass.includes('category') ? null : '매입채무및기타채무') :
                        item.name;

                    // 비유동 매입채무및기타채무는 별도 처리
                    let vcmRow;
                    if (item.name === '매입채무및기타채무' && !item.isCategory) {
                        const currentIndex = bsItems.indexOf(item);
                        let isNonCurrent = false;
                        for (let i = currentIndex - 1; i >= 0; i--) {
                            if (bsItems[i].name === '부채총계') break;
                            if (bsItems[i].name === '비유동부채') {
                                isNonCurrent = true;
                                break;
                            }
                            if (bsItems[i].name === '유동부채') break;
                        }
                        vcmRow = vcmDataList.find(row => row['항목'] === (isNonCurrent ? '매입채무및기타채무[비유동]' : '매입채무및기타채무'));
                    } else if (vcmItemName) {
                        vcmRow = vcmDataList.find(row => row['항목'] === vcmItemName);
                    }

                    if (vcmRow && vcmRow[y] !== null && vcmRow[y] !== undefined) {
                        val = parseValue(vcmRow[y]);
                        if (item.calc) {
                            const breakdown = getBsBreakdown(item.calc, y, vcmDataList);
                            if (!item.isCategory && breakdown.length >= 1) {
                                isMultipleItems = true;
                                tooltip = breakdown.map(b => `${b.name}: ${fmt(b.value)}`).join('\n');
                                tooltip = `[${y} 합산 내역]\n${tooltip}`;
                            }
                        }
                    } else {
                        // VCM에 없으면 기존 로직 사용
                        if (item.calc) {
                            val = calcBsValue(item.calc, y);
                            // 각 연도별 툴팁 생성 (카테고리 행은 제외 - 이미 회색으로 합계임을 표시)
                            const breakdown = getBsBreakdown(item.calc, y, vcmDataList);
                            if (!item.isCategory && breakdown.length >= 1) {  // 1개 이상이면 합산 내역 표시
                                isMultipleItems = true;
                                tooltip = breakdown.map(b => `${b.name}: ${fmt(b.value)}`).join('\n');
                                tooltip = `[${y} 합산 내역]\n${tooltip}`;
                            }
                        } else {
                            val = findValue(bsData, item.keywords, y, item.excludes || []);
                        }
                    }

                    bsTableHtml += `<td class="${isMultipleItems ? 'calc-cell' : ''}" title="${tooltip}">${fmt(val)}</td>`;
                });
                bsTableHtml += '</tr>';
            });
            
            // NWC 추가 (VCM 데이터에서 읽기 또는 계산)
            bsTableHtml += '<tr class="highlight-row"><td>NWC</td>';
            years.forEach(y => {
                let nwc, tooltip;

                // VCM 데이터에서 읽기 시도
                const vcmData = previewData?.vcm || [];
                const nwcRow = vcmData.find(row => row['항목'] === 'NWC');

                if (nwcRow && nwcRow[y] !== null && nwcRow[y] !== undefined) {
                    // 백엔드 VCM 값 사용 (단위 변환)
                    nwc = parseValue(nwcRow[y]);

                    // VCM에서 NWC 세부항목 가져오기
                    const nwcBreakdown = getVcmBreakdown('NWC', y, vcmData);
                    if (nwcBreakdown.length > 0) {
                        tooltip = `[${y} 계산식]\n`;
                        nwcBreakdown.forEach(b => {
                            tooltip += `${b.name.replace(' [NWC]', '')}: ${fmt(b.value)}\n`;
                        });
                        tooltip += `= NWC: ${fmt(nwc)}`;
                    } else {
                        const 유동자산 = findValue(bsData, ['Ⅰ.유동자산', '유동자산'], y, ['비유동']) || 0;
                        const 유동부채 = findValue(bsData, ['유동부채'], y, ['비유동']) || 0;
                        tooltip = `[${y} 계산식]\n유동자산: ${fmt(유동자산)}\n- 유동부채: ${fmt(유동부채)}\n= NWC: ${fmt(nwc)}`;
                    }
                } else {
                    // VCM 데이터 없으면 직접 계산
                    const 유동자산 = findValue(bsData, ['Ⅰ.유동자산', '유동자산'], y, ['비유동']) || 0;
                    const 유동부채 = findValue(bsData, ['유동부채'], y, ['비유동']) || 0;
                    nwc = 유동자산 - 유동부채;
                    tooltip = `[${y} 계산식]\n유동자산: ${fmt(유동자산)}\n- 유동부채: ${fmt(유동부채)}\n= NWC: ${fmt(nwc)}`;
                }

                bsTableHtml += `<td class="calc-cell" title="${tooltip}">${fmt(nwc)}</td>`;
            });
            bsTableHtml += '</tr>';
            
            bsTableHtml += '<tr class="highlight-row"><td>Net Debt</td>';
            years.forEach(y => {
                let netDebt, tooltip;

                // VCM 데이터에서 읽기 시도
                const vcmData = previewData?.vcm || [];
                const netDebtRow = vcmData.find(row => row['항목'] === 'Net Debt');

                if (netDebtRow && netDebtRow[y] !== null && netDebtRow[y] !== undefined) {
                    // 백엔드 VCM 값 사용 (단위 변환)
                    netDebt = parseValue(netDebtRow[y]);

                    // VCM에서 Net Debt 세부항목 가져오기
                    const netDebtBreakdown = getVcmBreakdown('Net Debt', y, vcmData);
                    if (netDebtBreakdown.length > 0) {
                        tooltip = `[${y} 계산식]\n`;
                        let 총차입금 = 0;
                        let 총현금성자산 = 0;

                        netDebtBreakdown.forEach(b => {
                            const name = b.name.replace(' [NetDebt]', '');
                            if (b.value > 0) {
                                tooltip += `+ ${name}: ${fmt(b.value)}\n`;
                                총차입금 += b.value;
                            } else if (b.value < 0) {
                                tooltip += `- ${name}: ${fmt(Math.abs(b.value))}\n`;
                                총현금성자산 += Math.abs(b.value);
                            }
                        });
                        tooltip += `= Net Debt: ${fmt(netDebt)}`;
                    } else {
                        // VCM 세부항목 없으면 기존 로직
                        const 단기차입금 = findValue(bsData, ['단기차입금'], y) || 0;
                        const 유동성장기차입금 = findValueWithCategory(bsData, ['유동성장기차입금', '유동성장기부채'], y, '유동부채') || 0;
                        const 유동성사채 = findValueWithCategory(bsData, ['유동성사채', '1년내상환사채'], y, '유동부채') || 0;
                        const 사채 = findValueWithCategory(bsData, ['사채'], y, '비유동부채', ['유동성', '차입금']) || 0;
                        const 장기차입금 = findValueWithCategory(bsData, ['장기차입금'], y, '비유동부채', ['유동성', '사채']) || 0;
                        const 총차입금 = 단기차입금 + 유동성장기차입금 + 유동성사채 + 사채 + 장기차입금;
                        const 현금 = findValue(bsData, ['현금및현금성자산'], y) || 0;
                        const 단기금융 = findValue(bsData, ['단기금융상품', '단기금융자산'], y) || 0;
                        const 총현금성자산 = 현금 + 단기금융;

                        tooltip = `[${y} 계산식]\n총차입금:\n`;
                        if (단기차입금) tooltip += `  단기차입금: ${fmt(단기차입금)}\n`;
                        if (유동성장기차입금) tooltip += `  유동성장기차입금: ${fmt(유동성장기차입금)}\n`;
                        if (유동성사채) tooltip += `  유동성사채: ${fmt(유동성사채)}\n`;
                        if (사채) tooltip += `  사채: ${fmt(사채)}\n`;
                        if (장기차입금) tooltip += `  장기차입금: ${fmt(장기차입금)}\n`;
                        tooltip += `= ${fmt(총차입금)}\n\n- 현금성자산:\n`;
                        if (현금) tooltip += `  현금: ${fmt(현금)}\n`;
                        if (단기금융) tooltip += `  단기금융: ${fmt(단기금융)}\n`;
                        tooltip += `= ${fmt(총현금성자산)}\n\nNet Debt: ${fmt(netDebt)}`;
                    }
                } else {
                    // VCM 데이터 없으면 직접 계산
                    const 단기차입금 = findValue(bsData, ['단기차입금'], y) || 0;
                    const 유동성장기차입금 = findValueWithCategory(bsData, ['유동성장기차입금', '유동성장기부채'], y, '유동부채') || 0;
                    const 유동성사채 = findValueWithCategory(bsData, ['유동성사채', '1년내상환사채'], y, '유동부채') || 0;
                    const 사채 = findValueWithCategory(bsData, ['사채'], y, '비유동부채', ['유동성', '차입금']) || 0;
                    const 장기차입금 = findValueWithCategory(bsData, ['장기차입금'], y, '비유동부채', ['유동성', '사채']) || 0;
                    const 총차입금 = 단기차입금 + 유동성장기차입금 + 유동성사채 + 사채 + 장기차입금;
                    const 현금 = findValue(bsData, ['현금및현금성자산'], y) || 0;
                    const 단기금융 = findValue(bsData, ['단기금융상품', '단기금융자산'], y) || 0;
                    const 총현금성자산 = 현금 + 단기금융;
                    netDebt = 총차입금 - 총현금성자산;

                    tooltip = `[${y} 계산식]\n총차입금:\n`;
                    if (단기차입금) tooltip += `  단기차입금: ${fmt(단기차입금)}\n`;
                    if (유동성장기차입금) tooltip += `  유동성장기차입금: ${fmt(유동성장기차입금)}\n`;
                    if (유동성사채) tooltip += `  유동성사채: ${fmt(유동성사채)}\n`;
                    if (사채) tooltip += `  사채: ${fmt(사채)}\n`;
                    if (장기차입금) tooltip += `  장기차입금: ${fmt(장기차입금)}\n`;
                    tooltip += `= ${fmt(총차입금)}\n\n- 현금성자산:\n`;
                    if (현금) tooltip += `  현금: ${fmt(현금)}\n`;
                    if (단기금융) tooltip += `  단기금융: ${fmt(단기금융)}\n`;
                    tooltip += `= ${fmt(총현금성자산)}\n\nNet Debt: ${fmt(netDebt)}`;
                }

                bsTableHtml += `<td class="calc-cell" title="${tooltip}">${fmt(netDebt)}</td>`;
            });
            bsTableHtml += '</tr>';
            bsTableHtml += '</tbody></table>';
            
            // 손익계산서 합산 항목의 상세 breakdown 반환 (툴팁용)
            function getIsBreakdown(calcType, year, vcmData) {
                // VCM 데이터에서 세부항목 찾기 시도
                if (vcmData && Array.isArray(vcmData)) {
                    let parentItem = null;
                    switch(calcType) {
                        case 'otherIncome': parentItem = '영업외수익'; break;
                        case 'otherExpense': parentItem = '영업외비용'; break;
                        case 'ebitda': parentItem = 'EBITDA'; break;
                    }
                    if (parentItem) {
                        const vcmBreakdown = getVcmBreakdown(parentItem, year, vcmData);
                        if (vcmBreakdown.length > 0) return vcmBreakdown;
                    }
                }

                const breakdown = [];

                // 동적 SGA 항목 처리
                if (calcType.startsWith('dynamic_sga_')) {
                    const itemName = calcType.replace('dynamic_sga_', '');
                    const itemConfig = sgaCandidates[itemName];
                    if (itemConfig && itemConfig.isSum) {
                        // 복수 키워드 합산인 경우 세부 내역 표시
                        for (let i = 0; i < itemConfig.keywords.length; i++) {
                            const val = findValueIS(isData, itemConfig.keywords[i], year, itemConfig.excludes[i]) || 0;
                            if (val > 0) {
                                breakdown.push({ name: itemConfig.keywords[i].join('/'), value: val });
                            }
                        }
                    }
                    return breakdown;
                }

                switch(calcType) {
                    case 'revenue':
                        const 상품매출 = findValueIS(isData, ['상품매출액', '상품매출'], year, ['원가']) || 0;
                        const 제품매출 = findValueIS(isData, ['제품매출액', '제품매출'], year, ['원가']) || 0;
                        const 기타매출 = findValueIS(isData, ['기타매출액', '기타매출'], year, ['원가']) || 0;
                        const 영업수익 = findValueIS(isData, ['영업수익'], year, ['원가']) || 0;
                        if (영업수익) breakdown.push({ name: '영업수익', value: 영업수익 });
                        if (상품매출) breakdown.push({ name: '상품매출', value: 상품매출 });
                        if (제품매출) breakdown.push({ name: '제품매출', value: 제품매출 });
                        if (기타매출) breakdown.push({ name: '기타매출', value: 기타매출 });
                        break;
                    case 'cogs':
                        const 상품원가 = findValueIS(isData, ['상품매출원가'], year) || 0;
                        const 제품원가 = findValueIS(isData, ['제품매출원가'], year) || 0;
                        if (상품원가) breakdown.push({ name: '상품매출원가', value: 상품원가 });
                        if (제품원가) breakdown.push({ name: '제품매출원가', value: 제품원가 });
                        break;
                    case 'sga':
                        // XBRL 통합 값이 있으면 breakdown 없음
                        const 판관비직접 = findValueIS(isData, ['판매비와관리비'], year) || 0;
                        if (!판관비직접) {
                            // 계산으로 구한 경우: 동적 선택된 상위 8개 항목 + 기타판관비
                            const yearIdx = years.indexOf(year);
                            for (const itemName of topSgaItems) {
                                const val = sgaItemValues[itemName][yearIdx];
                                if (val > 0) {
                                    breakdown.push({ name: itemName, value: val });
                                }
                            }

                            // 기타판관비 (선택되지 않은 항목들의 합)
                            let otherSgaSum = 0;
                            for (const [itemName, values] of Object.entries(sgaItemValues)) {
                                if (!topSgaItems.includes(itemName)) {
                                    otherSgaSum += values[yearIdx];
                                }
                            }
                            if (otherSgaSum > 0) {
                                breakdown.push({ name: '기타판매비와관리비', value: otherSgaSum });
                            }
                        }
                        break;
                    case 'otherSga':
                        // 기타판관비: 선택되지 않은 항목들만 표시
                        const yearIdx2 = years.indexOf(year);
                        for (const [itemName, values] of Object.entries(sgaItemValues)) {
                            if (!topSgaItems.includes(itemName)) {
                                const val = values[yearIdx2];
                                if (val > 0) {
                                    breakdown.push({ name: itemName, value: val });
                                }
                            }
                        }
                        break;
                    case 'otherIncome':
                        // 영업외수익 = 금융수익 + 기타수익 + 세부항목들
                        const 금융수익통합 = findValueIS(isData, ['금융수익'], year) || 0;
                        const 기타수익 = findValueIS(isData, ['기타수익', '기타이익'], year, ['금융', '영업외']) || 0;

                        if (금융수익통합) {
                            // 통합 계정 있으면 그것만 표시
                            breakdown.push({ name: '금융수익', value: 금융수익통합 });
                        } else {
                            // 통합 계정 없으면 세부 항목들 표시
                            const 이자수익 = findValueIS(isData, ['이자수익'], year) || 0;
                            const 배당금수익 = findValueIS(isData, ['배당금수익'], year) || 0;
                            const 외환차익 = findValueIS(isData, ['외환차익'], year) || 0;
                            const 임대료수익 = findValueIS(isData, ['임대료수익'], year) || 0;
                            const 잡이익 = findValueIS(isData, ['잡이익'], year) || 0;
                            const 유형자산처분이익 = findValueIS(isData, ['유형자산처분이익'], year) || 0;
                            if (이자수익) breakdown.push({ name: '이자수익', value: 이자수익 });
                            if (배당금수익) breakdown.push({ name: '배당금수익', value: 배당금수익 });
                            if (외환차익) breakdown.push({ name: '외환차익', value: 외환차익 });
                            if (임대료수익) breakdown.push({ name: '임대료수익', value: 임대료수익 });
                            if (잡이익) breakdown.push({ name: '잡이익', value: 잡이익 });
                            if (유형자산처분이익) breakdown.push({ name: '유형자산처분이익', value: 유형자산처분이익 });
                        }
                        if (기타수익) breakdown.push({ name: '기타수익', value: 기타수익 });
                        break;
                    case 'otherExpense':
                        // 영업외비용 = 금융비용 + 기타비용 + 세부항목들
                        const 금융비용통합 = findValueIS(isData, ['금융비용'], year) || 0;
                        const 기타비용 = findValueIS(isData, ['기타비용', '기타손실'], year, ['금융', '영업외']) || 0;

                        if (금융비용통합) {
                            // 통합 계정 있으면 그것만 표시
                            breakdown.push({ name: '금융비용', value: 금융비용통합 });
                        } else {
                            // 통합 계정 없으면 세부 항목들 표시
                            const 이자비용 = findValueIS(isData, ['이자비용'], year) || 0;
                            const 외환차손 = findValueIS(isData, ['외환차손'], year) || 0;
                            const 투자손상 = findValueIS(isData, ['투자자산손상차손', '투자손상차손'], year) || 0;
                            const 잡손실 = findValueIS(isData, ['잡손실'], year) || 0;
                            const 매출채권처분손실 = findValueIS(isData, ['매출채권처분손실'], year) || 0;
                            const 투자자산처분손실 = findValueIS(isData, ['투자자산처분손실'], year) || 0;
                            if (이자비용) breakdown.push({ name: '이자비용', value: 이자비용 });
                            if (외환차손) breakdown.push({ name: '외환차손', value: 외환차손 });
                            if (투자손상) breakdown.push({ name: '투자자산손상차손', value: 투자손상 });
                            if (잡손실) breakdown.push({ name: '잡손실', value: 잡손실 });
                            if (매출채권처분손실) breakdown.push({ name: '매출채권처분손실', value: 매출채권처분손실 });
                            if (투자자산처분손실) breakdown.push({ name: '투자자산처분손실', value: 투자자산처분손실 });
                        }
                        if (기타비용) breakdown.push({ name: '기타비용', value: 기타비용 });
                        break;
                }
                return breakdown;
            }

            // 손익계산서 계산 함수 (합계 항목용)
            // XBRL 통합 계정명 우선, 없으면 세부 항목 합산
            // 자동 단위 감지 (원/천원 혼재 대응)
            function calcValue(calcType, year) {
                // 동적 SGA 항목 처리
                if (calcType.startsWith('dynamic_sga_')) {
                    const itemName = calcType.replace('dynamic_sga_', '');
                    const yearIdx = years.indexOf(year);
                    if (yearIdx >= 0 && sgaItemValues[itemName]) {
                        return sgaItemValues[itemName][yearIdx];
                    }
                    return null;
                }

                // XBRL 통합 계정명으로 직접 검색 (대기업용) - 자동 단위 감지 적용
                const 매출액직접 = findValueIS(isData, ['매출액', '수익(매출액)', '영업수익', '수익'], year, ['원가', '총이익', '채권', '기타']);
                const 매출원가직접 = findValueIS(isData, ['매출원가', '영업비용', '매출비용'], year, ['판매비', '관리비', '총이익']);
                const 매출총이익직접 = findValueIS(isData, ['매출총이익', '매출총손익'], year);
                const 판관비직접 = findValueIS(isData, ['판매비와관리비', '판매비와관리비용', '판매비및관리비'], year);
                const 영업이익직접 = findValueIS(isData, ['영업이익', '영업손익', '영업이익(손실)'], year);
                const 기타수익직접 = findValueIS(isData, ['기타수익', '기타이익'], year, ['금융', '영업외']) || 0;
                const 기타비용직접 = findValueIS(isData, ['기타비용', '기타손실'], year, ['금융', '영업외']) || 0;
                const 금융수익직접 = findValueIS(isData, ['금융수익', '금융이익', '이자수익'], year) || 0;
                const 금융비용직접 = findValueIS(isData, ['금융비용', '금융원가', '이자비용'], year) || 0;
                const 법인세차감전직접 = findValueIS(isData, ['법인세비용차감전순이익', '법인세비용차감전이익', '법인세차감전순이익', '법인세비용차감전손익'], year);
                const 법인세직접 = findValueIS(isData, ['법인세비용', '법인세비용(수익)', '법인세등'], year, ['차감전']);
                const 당기순이익직접 = findValueIS(isData, ['당기순이익', '당기순손익', '분기순이익', '반기순이익'], year, ['지배', '비지배']);

                // 세부 항목 (중소기업/감사보고서용)
                const 상품매출 = findValueIS(isData, ['상품매출액', '상품매출'], year, ['원가']) || 0;
                const 제품매출 = findValueIS(isData, ['제품매출액', '제품매출'], year, ['원가']) || 0;
                const 기타매출 = findValueIS(isData, ['기타매출액', '기타매출', '기타수익'], year, ['원가']) || 0;
                const 상품원가 = findValueIS(isData, ['상품매출원가'], year) || 0;
                const 제품원가 = findValueIS(isData, ['제품매출원가'], year) || 0;

                // 동적 판관비 계산: 상위 8개 항목의 합 + 기타판관비
                const yearIdx = years.indexOf(year);
                let 선택된판관비합 = 0;
                let 기타판관비 = 0;

                // 모든 판관비 항목 값 계산
                for (const [itemName, itemConfig] of Object.entries(sgaCandidates)) {
                    let itemValue = 0;

                    if (itemConfig.isSum) {
                        // 복수 키워드 합산
                        for (let i = 0; i < itemConfig.keywords.length; i++) {
                            const val = findValueIS(isData, itemConfig.keywords[i], year, itemConfig.excludes[i]) || 0;
                            itemValue += val;
                        }
                    } else {
                        // 단일 키워드
                        itemValue = findValueIS(isData, itemConfig.keywords[0], year, itemConfig.excludes[0]) || 0;
                    }

                    // 상위 8개에 포함되면 선택된판관비합에, 아니면 기타판관비에 추가
                    if (topSgaItems.includes(itemName)) {
                        선택된판관비합 += itemValue;
                    } else {
                        기타판관비 += itemValue;
                    }
                }

                // 영업외 수익/비용 (자동 단위 감지)
                const 이자수익 = findValueIS(isData, ['이자수익'], year) || 0;
                const 배당금수익 = findValueIS(isData, ['배당금수익'], year) || 0;
                const 외환차익 = findValueIS(isData, ['외환차익'], year) || 0;
                const 임대료수익 = findValueIS(isData, ['임대료수익'], year) || 0;
                const 잡이익 = findValueIS(isData, ['잡이익'], year) || 0;
                const 유형자산처분이익 = findValueIS(isData, ['유형자산처분이익'], year) || 0;
                const 이자비용 = findValueIS(isData, ['이자비용'], year) || 0;
                const 외환차손 = findValueIS(isData, ['외환차손'], year) || 0;
                const 투자손상 = findValueIS(isData, ['투자자산손상차손'], year) || 0;
                const 잡손실 = findValueIS(isData, ['잡손실'], year) || 0;
                const 매출채권처분손실 = findValueIS(isData, ['매출채권처분손실'], year) || 0;
                const 투자자산처분손실 = findValueIS(isData, ['투자자산처분손실'], year) || 0;

                // 법인세 (여러 키워드로 검색)
                const 법인세 = findValueIS(isData, ['법인세비용', '법인세등'], year, ['차감전']) || 0;

                // 계산된 값 (세부 항목 합산 - 감사보고서용)
                const revenue계산 = 상품매출 + 제품매출 + 기타매출;
                const cogs계산 = 상품원가 + 제품원가;
                const sga계산 = 선택된판관비합 + 기타판관비;
                const 영업외수익계산 = 이자수익 + 배당금수익 + 외환차익 + 임대료수익 + 잡이익 + 유형자산처분이익;
                const 영업외비용계산 = 이자비용 + 외환차손 + 투자손상 + 잡손실 + 매출채권처분손실 + 투자자산처분손실;
                
                // XBRL 직접값 우선, 없으면 계산값 사용
                const revenue = 매출액직접 !== null ? 매출액직접 : revenue계산;
                const cogs = 매출원가직접 !== null ? 매출원가직접 : cogs계산;
                const grossProfit = 매출총이익직접 !== null ? 매출총이익직접 : (revenue - cogs);
                const sga = 판관비직접 !== null ? 판관비직접 : sga계산;
                const operatingIncome = 영업이익직접 !== null ? 영업이익직접 : (grossProfit - sga);
                
                // 영업외수익/비용: XBRL(기타수익+금융수익) 우선, 없으면 계산값
                const 영업외수익합 = (기타수익직접 + 금융수익직접) > 0 ? (기타수익직접 + 금융수익직접) : 영업외수익계산;
                const 영업외비용합 = (기타비용직접 + 금융비용직접) > 0 ? (기타비용직접 + 금융비용직접) : 영업외비용계산;
                
                // 법인세: XBRL 직접값 우선
                const 법인세최종 = 법인세직접 !== null ? 법인세직접 : 법인세;
                
                const ebt = 법인세차감전직접 !== null ? 법인세차감전직접 : (operatingIncome + 영업외수익합 - 영업외비용합);
                const netIncome = 당기순이익직접 !== null ? 당기순이익직접 : (ebt - 법인세최종);
                
                switch(calcType) {
                    case 'revenue': return revenue;
                    case 'cogs': return cogs;
                    case 'grossProfit': return grossProfit;
                    case 'sga': return sga;
                    case 'otherSga': return 기타판관비;
                    case 'operatingIncome': return operatingIncome;
                    case 'otherIncome': return 영업외수익합;
                    case 'otherExpense': return 영업외비용합;
                    case 'ebt': return ebt;
                    case 'tax': return 법인세최종;
                    case 'netIncome': return netIncome;
                    case 'financeIncome': return 금융수익직접;
                    case 'financeCost': return 금융비용직접;
                    default: return null;
                }
            }
            
            // VCM 항목 매칭 헬퍼 함수 (상품매출 vs 상품매출액 등 유연하게 매칭)
            function findVcmRow(vcmData, itemName) {
                return vcmData.find(row => {
                    const rowItem = (row['항목'] || '').trim();
                    const searchName = itemName.trim();
                    // 정확한 매칭
                    if (rowItem === searchName) return true;
                    // '액' 접미사 변형 매칭 (상품매출 ↔ 상품매출액)
                    if (rowItem === searchName + '액') return true;
                    if (rowItem + '액' === searchName) return true;
                    return false;
                });
            }

            // 손익계산서 테이블 생성
            let isTableHtml = '<table class="vcm-table"><thead>' + headerHtml + '</thead><tbody>';
            isItems.forEach(item => {
                // 빈 행 필터링: 모든 연도에 값이 없으면 건너뜀
                const vcmData = previewData?.vcm || [];
                const vcmRow = findVcmRow(vcmData, item.name);
                const hasAnyValue = years.some(y => {
                    if (vcmRow && vcmRow[y] !== null && vcmRow[y] !== undefined && vcmRow[y] !== 0) return true;
                    if (item.calc) {
                        const calcVal = calcValue(item.calc, y);
                        if (calcVal !== null && calcVal !== undefined && calcVal !== 0) return true;
                    }
                    // keywords 기반 항목도 체크 (상품매출, 제품매출 등)
                    if (item.keywords) {
                        const keyVal = findValue(isData, item.keywords, y, item.excludes || []);
                        if (keyVal !== null && keyVal !== undefined && keyVal !== 0) return true;
                    }
                    return false;
                });

                // 카테고리 행(매출, 매출원가 등 대분류)은 항상 표시, 나머지는 값이 있을 때만 표시
                if (!item.isCategory && !item.isTotal && !hasAnyValue) {
                    return; // 빈 행 건너뜀
                }

                let rowClass = item.isCategory ? 'category-row' : (item.isTotal ? 'total-row' : '');
                if (item.isHighlight) rowClass += ' highlight-row';
                let tdClass = item.isSubItem ? 'sub-item' : '';

                isTableHtml += `<tr class="${rowClass}"><td class="${tdClass}">${item.name}</td>`;
                years.forEach(y => {
                    let val;
                    let tooltip = '';
                    let isMultipleItems = false;

                    // VCM 데이터에서 먼저 찾기 시도
                    const vcmData = previewData?.vcm || [];
                    const vcmRow = findVcmRow(vcmData, item.name);

                    if (vcmRow && vcmRow[y] !== null && vcmRow[y] !== undefined) {
                        // VCM 데이터 사용 (단위 변환)
                        val = parseValue(vcmRow[y]);

                        // 합산 항목인 경우 툴팁 생성
                        if (item.calc) {
                            const breakdown = getIsBreakdown(item.calc, y, vcmData);
                            if (!item.isCategory && breakdown.length >= 1) {
                                isMultipleItems = true;
                                tooltip = breakdown.map(b => `${b.name}: ${fmt(b.value)}`).join('\n');
                                tooltip = `[${y} 합산 내역]\n${tooltip}`;
                            }
                        }
                    } else {
                        // VCM에 없으면 기존 로직 사용
                        if (item.calc) {
                            val = calcValue(item.calc, y);
                            // 각 연도별 툴팁 생성 (카테고리 행은 제외 - 이미 회색으로 합계임을 표시)
                            const breakdown = getIsBreakdown(item.calc, y, vcmData);
                            if (!item.isCategory && breakdown.length >= 1) {  // 1개 이상이면 합산 내역 표시
                                isMultipleItems = true;
                                tooltip = breakdown.map(b => `${b.name}: ${fmt(b.value)}`).join('\n');
                                tooltip = `[${y} 합산 내역]\n${tooltip}`;
                            }
                        } else {
                            val = findValue(isData, item.keywords, y, item.excludes || []);
                        }
                    }
                    // 값 표시 (빈칸 유지)
                    isTableHtml += `<td class="${isMultipleItems ? 'calc-cell' : ''}" title="${tooltip}">${fmt(val)}</td>`;
                });
                isTableHtml += '</tr>';
                
                // 매출총이익, 영업이익, 당기순이익 다음에 % of Sales 추가
                if (item.name === '매출총이익' || item.name === '영업이익' || item.name === '당기순이익') {
                    isTableHtml += '<tr class="percent-row"><td class="sub-item">% of Sales</td>';
                    years.forEach(y => {
                        const 매출 = calcValue('revenue', y) || 0;
                        let val;
                        if (item.calc) {
                            val = calcValue(item.calc, y);
                        } else {
                            val = findValue(isData, item.keywords, y, item.excludes || []);
                        }
                        isTableHtml += `<td>${pct(val, 매출)}</td>`;
                    });
                    isTableHtml += '</tr>';
                }
            });
            
            // EBITDA 추가 (VCM 데이터에서 읽기 또는 계산)
            isTableHtml += '<tr class="total-row highlight-row"><td>EBITDA</td>';
            const ebitdaValues = {};  // % of Sales 계산을 위해 저장
            years.forEach(y => {
                let ebitda, tooltip;

                // VCM 데이터에서 읽기 시도
                const vcmData = previewData?.vcm || [];
                const ebitdaRow = vcmData.find(row => row['항목'] === 'EBITDA');

                if (ebitdaRow && ebitdaRow[y] !== null && ebitdaRow[y] !== undefined) {
                    // 백엔드 VCM 값 사용 (단위 변환)
                    ebitda = parseValue(ebitdaRow[y]);

                    // 툴팁용 세부 데이터
                    const 영업이익 = calcValue('operatingIncome', y) || 0;
                    const 감가상각비 = findValue(isData, ['감가상각비'], y, ['무형']) || 0;
                    const 무형자산상각비 = findValue(isData, ['무형자산상각비'], y) || 0;

                    tooltip = `[${y} 계산식]\n영업이익: ${fmt(영업이익)}\n`;
                    if (감가상각비) tooltip += `+ 감가상각비: ${fmt(감가상각비)}\n`;
                    if (무형자산상각비) tooltip += `+ 무형자산상각비: ${fmt(무형자산상각비)}\n`;
                    tooltip += `= EBITDA: ${fmt(ebitda)}`;
                } else {
                    // VCM 데이터 없으면 직접 계산
                    const 영업이익 = calcValue('operatingIncome', y) || 0;
                    const 감가상각비 = findValue(isData, ['감가상각비'], y, ['무형']) || 0;
                    const 무형자산상각비 = findValue(isData, ['무형자산상각비'], y) || 0;
                    ebitda = 영업이익 + 감가상각비 + 무형자산상각비;

                    tooltip = `[${y} 계산식]\n영업이익: ${fmt(영업이익)}\n`;
                    if (감가상각비) tooltip += `+ 감가상각비: ${fmt(감가상각비)}\n`;
                    if (무형자산상각비) tooltip += `+ 무형자산상각비: ${fmt(무형자산상각비)}\n`;
                    tooltip += `= EBITDA: ${fmt(ebitda)}`;
                }

                ebitdaValues[y] = ebitda;
                isTableHtml += `<td class="calc-cell" title="${tooltip}">${fmt(ebitda)}</td>`;
            });
            isTableHtml += '</tr>';
            isTableHtml += '<tr class="percent-row"><td class="sub-item">% of Sales</td>';
            years.forEach(y => {
                const 매출 = calcValue('revenue', y) || 0;
                const ebitda = ebitdaValues[y];
                isTableHtml += `<td>${pct(ebitda, 매출)}</td>`;
            });
            isTableHtml += '</tr>';
            isTableHtml += '</tbody></table>';
            
            // 최종 HTML
            return `
                <div class="vcm-container">
                    <div class="vcm-section">
                        <div class="vcm-title">재무상태표</div>
                        ${bsTableHtml}
                    </div>
                    <div class="vcm-section">
                        <div class="vcm-title">손익계산서</div>
                        ${isTableHtml}
                    </div>
                </div>
                <p class="preview-info">* Source: 전자공시시스템 (DART)</p>
            `;
        }
        
        function downloadFile() {
            if (!currentTaskId) return;
            // 페이지 이동 없이 다운로드 (화면 유지)
            const link = document.createElement('a');
            link.href = `/api/download/${currentTaskId}`;
            link.download = '';  // 서버에서 파일명 지정
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        
        // ============================================================
        // 초기화
        // ============================================================
        function resetAll() {
            stopStatusCheck();
            
            // 작업 삭제
            if (currentTaskId) {
                fetch(`/api/task/${currentTaskId}`, { method: 'DELETE' }).catch(() => {});
                currentTaskId = null;
            }
            
            selectedCorp = null;
            previewData = null;
            
            // UI 초기화
            document.getElementById('companyInput').value = '';
            document.getElementById('searchResults').classList.remove('show');
            document.getElementById('progressSection').classList.remove('show');
            document.getElementById('extractingSection').classList.remove('show');
            document.getElementById('completeSection').classList.remove('show');
            hideError();
            
            // 진행바 초기화
            const progressBar = document.getElementById('progressBar');
            progressBar.style.width = '0%';
            progressBar.textContent = '0%';
        }
        
        // ============================================================
        // 에러 처리
        // ============================================================
        function showError(message) {
            const errorEl = document.getElementById('errorMessage');
            errorEl.textContent = message;
            errorEl.classList.add('show');
        }
        
        function hideError() {
            document.getElementById('errorMessage').classList.remove('show');
        }
    </script>
</body>
</html>
